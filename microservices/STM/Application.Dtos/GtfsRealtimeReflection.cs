// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: gtfs-realtime.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021, 8981
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace STM.ExternalServiceProvider.Proto
{

    /// <summary>Holder for reflection information generated from gtfs-realtime.proto</summary>
    public static partial class GtfsRealtimeReflection
    {

        #region Descriptor
        /// <summary>File descriptor for gtfs-realtime.proto</summary>
        public static pbr::FileDescriptor Descriptor
        {
            get { return descriptor; }
        }
        private static pbr::FileDescriptor descriptor;

        static GtfsRealtimeReflection()
        {
            byte[] descriptorData = global::System.Convert.FromBase64String(
                string.Concat(
                  "ChNndGZzLXJlYWx0aW1lLnByb3RvEhB0cmFuc2l0X3JlYWx0aW1lInEKC0Zl",
                  "ZWRNZXNzYWdlEiwKBmhlYWRlchgBIAIoCzIcLnRyYW5zaXRfcmVhbHRpbWUu",
                  "RmVlZEhlYWRlchIsCgZlbnRpdHkYAiADKAsyHC50cmFuc2l0X3JlYWx0aW1l",
                  "LkZlZWRFbnRpdHkqBgjoBxDQDyLPAQoKRmVlZEhlYWRlchIdChVndGZzX3Jl",
                  "YWx0aW1lX3ZlcnNpb24YASACKAkSUQoOaW5jcmVtZW50YWxpdHkYAiABKA4y",
                  "Ky50cmFuc2l0X3JlYWx0aW1lLkZlZWRIZWFkZXIuSW5jcmVtZW50YWxpdHk6",
                  "DEZVTExfREFUQVNFVBIRCgl0aW1lc3RhbXAYAyABKAQiNAoOSW5jcmVtZW50",
                  "YWxpdHkSEAoMRlVMTF9EQVRBU0VUEAASEAoMRElGRkVSRU5USUFMEAEqBgjo",
                  "BxDQDyLKAQoKRmVlZEVudGl0eRIKCgJpZBgBIAIoCRIZCgppc19kZWxldGVk",
                  "GAIgASgIOgVmYWxzZRIxCgt0cmlwX3VwZGF0ZRgDIAEoCzIcLnRyYW5zaXRf",
                  "cmVhbHRpbWUuVHJpcFVwZGF0ZRIyCgd2ZWhpY2xlGAQgASgLMiEudHJhbnNp",
                  "dF9yZWFsdGltZS5WZWhpY2xlUG9zaXRpb24SJgoFYWxlcnQYBSABKAsyFy50",
                  "cmFuc2l0X3JlYWx0aW1lLkFsZXJ0KgYI6AcQ0A8imgUKClRyaXBVcGRhdGUS",
                  "LgoEdHJpcBgBIAIoCzIgLnRyYW5zaXRfcmVhbHRpbWUuVHJpcERlc2NyaXB0",
                  "b3ISNAoHdmVoaWNsZRgDIAEoCzIjLnRyYW5zaXRfcmVhbHRpbWUuVmVoaWNs",
                  "ZURlc2NyaXB0b3ISRQoQc3RvcF90aW1lX3VwZGF0ZRgCIAMoCzIrLnRyYW5z",
                  "aXRfcmVhbHRpbWUuVHJpcFVwZGF0ZS5TdG9wVGltZVVwZGF0ZRIRCgl0aW1l",
                  "c3RhbXAYBCABKAQSDQoFZGVsYXkYBSABKAUaSQoNU3RvcFRpbWVFdmVudBIN",
                  "CgVkZWxheRgBIAEoBRIMCgR0aW1lGAIgASgDEhMKC3VuY2VydGFpbnR5GAMg",
                  "ASgFKgYI6AcQ0A8a6QIKDlN0b3BUaW1lVXBkYXRlEhUKDXN0b3Bfc2VxdWVu",
                  "Y2UYASABKA0SDwoHc3RvcF9pZBgEIAEoCRI7CgdhcnJpdmFsGAIgASgLMiou",
                  "dHJhbnNpdF9yZWFsdGltZS5UcmlwVXBkYXRlLlN0b3BUaW1lRXZlbnQSPQoJ",
                  "ZGVwYXJ0dXJlGAMgASgLMioudHJhbnNpdF9yZWFsdGltZS5UcmlwVXBkYXRl",
                  "LlN0b3BUaW1lRXZlbnQSagoVc2NoZWR1bGVfcmVsYXRpb25zaGlwGAUgASgO",
                  "MkAudHJhbnNpdF9yZWFsdGltZS5UcmlwVXBkYXRlLlN0b3BUaW1lVXBkYXRl",
                  "LlNjaGVkdWxlUmVsYXRpb25zaGlwOglTQ0hFRFVMRUQiPwoUU2NoZWR1bGVS",
                  "ZWxhdGlvbnNoaXASDQoJU0NIRURVTEVEEAASCwoHU0tJUFBFRBABEgsKB05P",
                  "X0RBVEEQAioGCOgHENAPKgYI6AcQ0A8i4AYKD1ZlaGljbGVQb3NpdGlvbhIu",
                  "CgR0cmlwGAEgASgLMiAudHJhbnNpdF9yZWFsdGltZS5UcmlwRGVzY3JpcHRv",
                  "chI0Cgd2ZWhpY2xlGAggASgLMiMudHJhbnNpdF9yZWFsdGltZS5WZWhpY2xl",
                  "RGVzY3JpcHRvchIsCghwb3NpdGlvbhgCIAEoCzIaLnRyYW5zaXRfcmVhbHRp",
                  "bWUuUG9zaXRpb24SHQoVY3VycmVudF9zdG9wX3NlcXVlbmNlGAMgASgNEg8K",
                  "B3N0b3BfaWQYByABKAkSWgoOY3VycmVudF9zdGF0dXMYBCABKA4yMy50cmFu",
                  "c2l0X3JlYWx0aW1lLlZlaGljbGVQb3NpdGlvbi5WZWhpY2xlU3RvcFN0YXR1",
                  "czoNSU5fVFJBTlNJVF9UTxIRCgl0aW1lc3RhbXAYBSABKAQSSwoQY29uZ2Vz",
                  "dGlvbl9sZXZlbBgGIAEoDjIxLnRyYW5zaXRfcmVhbHRpbWUuVmVoaWNsZVBv",
                  "c2l0aW9uLkNvbmdlc3Rpb25MZXZlbBJLChBvY2N1cGFuY3lfc3RhdHVzGAkg",
                  "ASgOMjEudHJhbnNpdF9yZWFsdGltZS5WZWhpY2xlUG9zaXRpb24uT2NjdXBh",
                  "bmN5U3RhdHVzIkcKEVZlaGljbGVTdG9wU3RhdHVzEg8KC0lOQ09NSU5HX0FU",
                  "EAASDgoKU1RPUFBFRF9BVBABEhEKDUlOX1RSQU5TSVRfVE8QAiJ9Cg9Db25n",
                  "ZXN0aW9uTGV2ZWwSHAoYVU5LTk9XTl9DT05HRVNUSU9OX0xFVkVMEAASFAoQ",
                  "UlVOTklOR19TTU9PVEhMWRABEg8KC1NUT1BfQU5EX0dPEAISDgoKQ09OR0VT",
                  "VElPThADEhUKEVNFVkVSRV9DT05HRVNUSU9OEAQirwEKD09jY3VwYW5jeVN0",
                  "YXR1cxIJCgVFTVBUWRAAEhgKFE1BTllfU0VBVFNfQVZBSUxBQkxFEAESFwoT",
                  "RkVXX1NFQVRTX0FWQUlMQUJMRRACEhYKElNUQU5ESU5HX1JPT01fT05MWRAD",
                  "Eh4KGkNSVVNIRURfU1RBTkRJTkdfUk9PTV9PTkxZEAQSCAoERlVMTBAFEhwK",
                  "GE5PVF9BQ0NFUFRJTkdfUEFTU0VOR0VSUxAGKgYI6AcQ0A8itgYKBUFsZXJ0",
                  "EjIKDWFjdGl2ZV9wZXJpb2QYASADKAsyGy50cmFuc2l0X3JlYWx0aW1lLlRp",
                  "bWVSYW5nZRI5Cg9pbmZvcm1lZF9lbnRpdHkYBSADKAsyIC50cmFuc2l0X3Jl",
                  "YWx0aW1lLkVudGl0eVNlbGVjdG9yEjsKBWNhdXNlGAYgASgOMh0udHJhbnNp",
                  "dF9yZWFsdGltZS5BbGVydC5DYXVzZToNVU5LTk9XTl9DQVVTRRI+CgZlZmZl",
                  "Y3QYByABKA4yHi50cmFuc2l0X3JlYWx0aW1lLkFsZXJ0LkVmZmVjdDoOVU5L",
                  "Tk9XTl9FRkZFQ1QSLwoDdXJsGAggASgLMiIudHJhbnNpdF9yZWFsdGltZS5U",
                  "cmFuc2xhdGVkU3RyaW5nEjcKC2hlYWRlcl90ZXh0GAogASgLMiIudHJhbnNp",
                  "dF9yZWFsdGltZS5UcmFuc2xhdGVkU3RyaW5nEjwKEGRlc2NyaXB0aW9uX3Rl",
                  "eHQYCyABKAsyIi50cmFuc2l0X3JlYWx0aW1lLlRyYW5zbGF0ZWRTdHJpbmci",
                  "2AEKBUNhdXNlEhEKDVVOS05PV05fQ0FVU0UQARIPCgtPVEhFUl9DQVVTRRAC",
                  "EhUKEVRFQ0hOSUNBTF9QUk9CTEVNEAMSCgoGU1RSSUtFEAQSEQoNREVNT05T",
                  "VFJBVElPThAFEgwKCEFDQ0lERU5UEAYSCwoHSE9MSURBWRAHEgsKB1dFQVRI",
                  "RVIQCBIPCgtNQUlOVEVOQU5DRRAJEhAKDENPTlNUUlVDVElPThAKEhMKD1BP",
                  "TElDRV9BQ1RJVklUWRALEhUKEU1FRElDQUxfRU1FUkdFTkNZEAwitQEKBkVm",
                  "ZmVjdBIOCgpOT19TRVJWSUNFEAESEwoPUkVEVUNFRF9TRVJWSUNFEAISFgoS",
                  "U0lHTklGSUNBTlRfREVMQVlTEAMSCgoGREVUT1VSEAQSFgoSQURESVRJT05B",
                  "TF9TRVJWSUNFEAUSFAoQTU9ESUZJRURfU0VSVklDRRAGEhAKDE9USEVSX0VG",
                  "RkVDVBAHEhIKDlVOS05PV05fRUZGRUNUEAgSDgoKU1RPUF9NT1ZFRBAJKgYI",
                  "6AcQ0A8iLwoJVGltZVJhbmdlEg0KBXN0YXJ0GAEgASgEEgsKA2VuZBgCIAEo",
                  "BCoGCOgHENAPImkKCFBvc2l0aW9uEhAKCGxhdGl0dWRlGAEgAigCEhEKCWxv",
                  "bmdpdHVkZRgCIAIoAhIPCgdiZWFyaW5nGAMgASgCEhAKCG9kb21ldGVyGAQg",
                  "ASgBEg0KBXNwZWVkGAUgASgCKgYI6AcQ0A8ioAIKDlRyaXBEZXNjcmlwdG9y",
                  "Eg8KB3RyaXBfaWQYASABKAkSEAoIcm91dGVfaWQYBSABKAkSFAoMZGlyZWN0",
                  "aW9uX2lkGAYgASgNEhIKCnN0YXJ0X3RpbWUYAiABKAkSEgoKc3RhcnRfZGF0",
                  "ZRgDIAEoCRJUChVzY2hlZHVsZV9yZWxhdGlvbnNoaXAYBCABKA4yNS50cmFu",
                  "c2l0X3JlYWx0aW1lLlRyaXBEZXNjcmlwdG9yLlNjaGVkdWxlUmVsYXRpb25z",
                  "aGlwIk8KFFNjaGVkdWxlUmVsYXRpb25zaGlwEg0KCVNDSEVEVUxFRBAAEgkK",
                  "BUFEREVEEAESDwoLVU5TQ0hFRFVMRUQQAhIMCghDQU5DRUxFRBADKgYI6AcQ",
                  "0A8iTQoRVmVoaWNsZURlc2NyaXB0b3ISCgoCaWQYASABKAkSDQoFbGFiZWwY",
                  "AiABKAkSFQoNbGljZW5zZV9wbGF0ZRgDIAEoCSoGCOgHENAPIpIBCg5FbnRp",
                  "dHlTZWxlY3RvchIRCglhZ2VuY3lfaWQYASABKAkSEAoIcm91dGVfaWQYAiAB",
                  "KAkSEgoKcm91dGVfdHlwZRgDIAEoBRIuCgR0cmlwGAQgASgLMiAudHJhbnNp",
                  "dF9yZWFsdGltZS5UcmlwRGVzY3JpcHRvchIPCgdzdG9wX2lkGAUgASgJKgYI",
                  "6AcQ0A8ilgEKEFRyYW5zbGF0ZWRTdHJpbmcSQwoLdHJhbnNsYXRpb24YASAD",
                  "KAsyLi50cmFuc2l0X3JlYWx0aW1lLlRyYW5zbGF0ZWRTdHJpbmcuVHJhbnNs",
                  "YXRpb24aNQoLVHJhbnNsYXRpb24SDAoEdGV4dBgBIAIoCRIQCghsYW5ndWFn",
                  "ZRgCIAEoCSoGCOgHENAPKgYI6AcQ0A9CHQobY29tLmdvb2dsZS50cmFuc2l0",
                  "LnJlYWx0aW1l"));
            descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
                new pbr::FileDescriptor[] { },
                new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::STM.ExternalServiceProvider.Proto.FeedMessage), global::STM.ExternalServiceProvider.Proto.FeedMessage.Parser, new[]{ "Header", "Entity" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::STM.ExternalServiceProvider.Proto.FeedHeader), global::STM.ExternalServiceProvider.Proto.FeedHeader.Parser, new[]{ "GtfsRealtimeVersion", "Incrementality", "Timestamp" }, null, new[]{ typeof(global::STM.ExternalServiceProvider.Proto.FeedHeader.Types.Incrementality) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::STM.ExternalServiceProvider.Proto.FeedEntity), global::STM.ExternalServiceProvider.Proto.FeedEntity.Parser, new[]{ "Id", "IsDeleted", "TripUpdate", "Vehicle", "Alert" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::STM.ExternalServiceProvider.Proto.TripUpdate), global::STM.ExternalServiceProvider.Proto.TripUpdate.Parser, new[]{ "Ride", "Vehicle", "StopTimeUpdate", "Timestamp", "Delay" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::STM.ExternalServiceProvider.Proto.TripUpdate.Types.StopTimeEvent), global::STM.ExternalServiceProvider.Proto.TripUpdate.Types.StopTimeEvent.Parser, new[]{ "Delay", "Time", "Uncertainty" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::STM.ExternalServiceProvider.Proto.TripUpdate.Types.StopTimeUpdate), global::STM.ExternalServiceProvider.Proto.TripUpdate.Types.StopTimeUpdate.Parser, new[]{ "StopSequence", "StopId", "Arrival", "Departure", "ScheduleRelationship" }, null, new[]{ typeof(global::STM.ExternalServiceProvider.Proto.TripUpdate.Types.StopTimeUpdate.Types.ScheduleRelationship) }, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::STM.ExternalServiceProvider.Proto.VehiclePosition), global::STM.ExternalServiceProvider.Proto.VehiclePosition.Parser, new[]{ "Ride", "Vehicle", "Position", "CurrentStopSequence", "StopId", "CurrentStatus", "Timestamp", "CongestionLevel", "OccupancyStatus" }, null, new[]{ typeof(global::STM.ExternalServiceProvider.Proto.VehiclePosition.Types.VehicleStopStatus), typeof(global::STM.ExternalServiceProvider.Proto.VehiclePosition.Types.CongestionLevel), typeof(global::STM.ExternalServiceProvider.Proto.VehiclePosition.Types.OccupancyStatus) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::STM.ExternalServiceProvider.Proto.Alert), global::STM.ExternalServiceProvider.Proto.Alert.Parser, new[]{ "ActivePeriod", "InformedEntity", "Cause", "Effect", "Url", "HeaderText", "DescriptionText" }, null, new[]{ typeof(global::STM.ExternalServiceProvider.Proto.Alert.Types.Cause), typeof(global::STM.ExternalServiceProvider.Proto.Alert.Types.Effect) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::STM.ExternalServiceProvider.Proto.TimeRange), global::STM.ExternalServiceProvider.Proto.TimeRange.Parser, new[]{ "Start", "End" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::STM.ExternalServiceProvider.Proto.Position), global::STM.ExternalServiceProvider.Proto.Position.Parser, new[]{ "Latitude", "Longitude", "Bearing", "Odometer", "Speed" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::STM.ExternalServiceProvider.Proto.TripDescriptor), global::STM.ExternalServiceProvider.Proto.TripDescriptor.Parser, new[]{ "TripId", "RouteId", "DirectionId", "StartTime", "StartDate", "ScheduleRelationship" }, null, new[]{ typeof(global::STM.ExternalServiceProvider.Proto.TripDescriptor.Types.ScheduleRelationship) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::STM.ExternalServiceProvider.Proto.VehicleDescriptor), global::STM.ExternalServiceProvider.Proto.VehicleDescriptor.Parser, new[]{ "Id", "Label", "LicensePlate" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::STM.ExternalServiceProvider.Proto.EntitySelector), global::STM.ExternalServiceProvider.Proto.EntitySelector.Parser, new[]{ "AgencyId", "RouteId", "RouteType", "Ride", "StopId" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::STM.ExternalServiceProvider.Proto.TranslatedString), global::STM.ExternalServiceProvider.Proto.TranslatedString.Parser, new[]{ "Translation" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::STM.ExternalServiceProvider.Proto.TranslatedString.Types.Translation), global::STM.ExternalServiceProvider.Proto.TranslatedString.Types.Translation.Parser, new[]{ "Text", "Language" }, null, null, null, null)})
                }));
        }
        #endregion

    }
    #region Messages
    /// <summary>
    /// The contents of a feed message.
    /// A feed is a continuous stream of feed messages. Each message in the stream is
    /// obtained as a response to an appropriate HTTP GET request.
    /// A realtime feed is always defined with relation to an existing GTFS feed.
    /// All the entity ids are resolved with respect to the GTFS feed.
    /// Note that "required" and "optional" as stated in this file refer to Protocol
    /// Buffer cardinality, not semantic cardinality.  See reference.md at
    /// https://github.com/google/transit/tree/master/gtfs-realtime for field
    /// semantic cardinality.
    /// </summary>
    public sealed partial class FeedMessage : pb::IExtendableMessage<FeedMessage>
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
#endif
    {
        private static readonly pb::MessageParser<FeedMessage> _parser = new pb::MessageParser<FeedMessage>(() => new FeedMessage());
        private pb::UnknownFieldSet _unknownFields;
        private pb::ExtensionSet<FeedMessage> _extensions;
        private pb::ExtensionSet<FeedMessage> _Extensions { get { return _extensions; } }
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<FeedMessage> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor
        {
            get { return global::STM.ExternalServiceProvider.Proto.GtfsRealtimeReflection.Descriptor.MessageTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor
        {
            get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public FeedMessage()
        {
            OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public FeedMessage(FeedMessage other) : this()
        {
            header_ = other.header_ != null ? other.header_.Clone() : null;
            entity_ = other.entity_.Clone();
            _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            _extensions = pb::ExtensionSet.Clone(other._extensions);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public FeedMessage Clone()
        {
            return new FeedMessage(this);
        }

        /// <summary>Field number for the "header" field.</summary>
        public const int HeaderFieldNumber = 1;
        private global::STM.ExternalServiceProvider.Proto.FeedHeader header_;
        /// <summary>
        /// Metadata about this feed and feed message.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::STM.ExternalServiceProvider.Proto.FeedHeader Header
        {
            get { return header_; }
            set
            {
                header_ = value;
            }
        }

        /// <summary>Field number for the "entity" field.</summary>
        public const int EntityFieldNumber = 2;
        private static readonly pb::FieldCodec<global::STM.ExternalServiceProvider.Proto.FeedEntity> _repeated_entity_codec
            = pb::FieldCodec.ForMessage(18, global::STM.ExternalServiceProvider.Proto.FeedEntity.Parser);
        private readonly pbc::RepeatedField<global::STM.ExternalServiceProvider.Proto.FeedEntity> entity_ = new pbc::RepeatedField<global::STM.ExternalServiceProvider.Proto.FeedEntity>();
        /// <summary>
        /// Contents of the feed.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public pbc::RepeatedField<global::STM.ExternalServiceProvider.Proto.FeedEntity> Entity
        {
            get { return entity_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other)
        {
            return Equals(other as FeedMessage);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(FeedMessage other)
        {
            if (ReferenceEquals(other, null))
            {
                return false;
            }
            if (ReferenceEquals(other, this))
            {
                return true;
            }
            if (!object.Equals(Header, other.Header)) return false;
            if (!entity_.Equals(other.entity_)) return false;
            if (!Equals(_extensions, other._extensions))
            {
                return false;
            }
            return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode()
        {
            int hash = 1;
            if (header_ != null) hash ^= Header.GetHashCode();
            hash ^= entity_.GetHashCode();
            if (_extensions != null)
            {
                hash ^= _extensions.GetHashCode();
            }
            if (_unknownFields != null)
            {
                hash ^= _unknownFields.GetHashCode();
            }
            return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString()
        {
            return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output)
        {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            output.WriteRawMessage(this);
#else
      if (header_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Header);
      }
      entity_.WriteTo(output, _repeated_entity_codec);
      if (_extensions != null) {
        _extensions.WriteTo(output);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
#endif
        }

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output)
        {
            if (header_ != null)
            {
                output.WriteRawTag(10);
                output.WriteMessage(Header);
            }
            entity_.WriteTo(ref output, _repeated_entity_codec);
            if (_extensions != null)
            {
                _extensions.WriteTo(ref output);
            }
            if (_unknownFields != null)
            {
                _unknownFields.WriteTo(ref output);
            }
        }
#endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize()
        {
            int size = 0;
            if (header_ != null)
            {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(Header);
            }
            size += entity_.CalculateSize(_repeated_entity_codec);
            if (_extensions != null)
            {
                size += _extensions.CalculateSize();
            }
            if (_unknownFields != null)
            {
                size += _unknownFields.CalculateSize();
            }
            return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(FeedMessage other)
        {
            if (other == null)
            {
                return;
            }
            if (other.header_ != null)
            {
                if (header_ == null)
                {
                    Header = new global::STM.ExternalServiceProvider.Proto.FeedHeader();
                }
                Header.MergeFrom(other.Header);
            }
            entity_.Add(other.entity_);
            pb::ExtensionSet.MergeFrom(ref _extensions, other._extensions);
            _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input)
        {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            input.ReadRawMessage(this);
#else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            if (!pb::ExtensionSet.TryMergeFieldFrom(ref _extensions, input)) {
              _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            }
            break;
          case 10: {
            if (header_ == null) {
              Header = new global::TransitRealtime.FeedHeader();
            }
            input.ReadMessage(Header);
            break;
          }
          case 18: {
            entity_.AddEntriesFrom(input, _repeated_entity_codec);
            break;
          }
        }
      }
#endif
        }

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input)
        {
            uint tag;
            while ((tag = input.ReadTag()) != 0)
            {
                switch (tag)
                {
                    default:
                        if (!pb::ExtensionSet.TryMergeFieldFrom(ref _extensions, ref input))
                        {
                            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                        }
                        break;
                    case 10:
                        {
                            if (header_ == null)
                            {
                                Header = new global::STM.ExternalServiceProvider.Proto.FeedHeader();
                            }
                            input.ReadMessage(Header);
                            break;
                        }
                    case 18:
                        {
                            entity_.AddEntriesFrom(ref input, _repeated_entity_codec);
                            break;
                        }
                }
            }
        }
#endif

        public TValue GetExtension<TValue>(pb::Extension<FeedMessage, TValue> extension)
        {
            return pb::ExtensionSet.Get(ref _extensions, extension);
        }
        public pbc::RepeatedField<TValue> GetExtension<TValue>(pb::RepeatedExtension<FeedMessage, TValue> extension)
        {
            return pb::ExtensionSet.Get(ref _extensions, extension);
        }
        public pbc::RepeatedField<TValue> GetOrInitializeExtension<TValue>(pb::RepeatedExtension<FeedMessage, TValue> extension)
        {
            return pb::ExtensionSet.GetOrInitialize(ref _extensions, extension);
        }
        public void SetExtension<TValue>(pb::Extension<FeedMessage, TValue> extension, TValue value)
        {
            pb::ExtensionSet.Set(ref _extensions, extension, value);
        }
        public bool HasExtension<TValue>(pb::Extension<FeedMessage, TValue> extension)
        {
            return pb::ExtensionSet.Has(ref _extensions, extension);
        }
        public void ClearExtension<TValue>(pb::Extension<FeedMessage, TValue> extension)
        {
            pb::ExtensionSet.Clear(ref _extensions, extension);
        }
        public void ClearExtension<TValue>(pb::RepeatedExtension<FeedMessage, TValue> extension)
        {
            pb::ExtensionSet.Clear(ref _extensions, extension);
        }

    }

    /// <summary>
    /// Metadata about a feed, included in feed messages.
    /// </summary>
    public sealed partial class FeedHeader : pb::IExtendableMessage<FeedHeader>
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
#endif
    {
        private static readonly pb::MessageParser<FeedHeader> _parser = new pb::MessageParser<FeedHeader>(() => new FeedHeader());
        private pb::UnknownFieldSet _unknownFields;
        private pb::ExtensionSet<FeedHeader> _extensions;
        private pb::ExtensionSet<FeedHeader> _Extensions { get { return _extensions; } }
        private int _hasBits0;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<FeedHeader> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor
        {
            get { return global::STM.ExternalServiceProvider.Proto.GtfsRealtimeReflection.Descriptor.MessageTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor
        {
            get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public FeedHeader()
        {
            OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public FeedHeader(FeedHeader other) : this()
        {
            _hasBits0 = other._hasBits0;
            gtfsRealtimeVersion_ = other.gtfsRealtimeVersion_;
            incrementality_ = other.incrementality_;
            timestamp_ = other.timestamp_;
            _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            _extensions = pb::ExtensionSet.Clone(other._extensions);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public FeedHeader Clone()
        {
            return new FeedHeader(this);
        }

        /// <summary>Field number for the "gtfs_realtime_version" field.</summary>
        public const int GtfsRealtimeVersionFieldNumber = 1;
        private readonly static string GtfsRealtimeVersionDefaultValue = "";

        private string gtfsRealtimeVersion_;
        /// <summary>
        /// Version of the feed specification.
        /// The current version is 2.0.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public string GtfsRealtimeVersion
        {
            get { return gtfsRealtimeVersion_ ?? GtfsRealtimeVersionDefaultValue; }
            set
            {
                gtfsRealtimeVersion_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
            }
        }
        /// <summary>Gets whether the "gtfs_realtime_version" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasGtfsRealtimeVersion
        {
            get { return gtfsRealtimeVersion_ != null; }
        }
        /// <summary>Clears the value of the "gtfs_realtime_version" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearGtfsRealtimeVersion()
        {
            gtfsRealtimeVersion_ = null;
        }

        /// <summary>Field number for the "incrementality" field.</summary>
        public const int IncrementalityFieldNumber = 2;
        private readonly static global::STM.ExternalServiceProvider.Proto.FeedHeader.Types.Incrementality IncrementalityDefaultValue = global::STM.ExternalServiceProvider.Proto.FeedHeader.Types.Incrementality.FullDataset;

        private global::STM.ExternalServiceProvider.Proto.FeedHeader.Types.Incrementality incrementality_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::STM.ExternalServiceProvider.Proto.FeedHeader.Types.Incrementality Incrementality
        {
            get { if ((_hasBits0 & 1) != 0) { return incrementality_; } else { return IncrementalityDefaultValue; } }
            set
            {
                _hasBits0 |= 1;
                incrementality_ = value;
            }
        }
        /// <summary>Gets whether the "incrementality" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasIncrementality
        {
            get { return (_hasBits0 & 1) != 0; }
        }
        /// <summary>Clears the value of the "incrementality" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearIncrementality()
        {
            _hasBits0 &= ~1;
        }

        /// <summary>Field number for the "timestamp" field.</summary>
        public const int TimestampFieldNumber = 3;
        private readonly static ulong TimestampDefaultValue = 0UL;

        private ulong timestamp_;
        /// <summary>
        /// This timestamp identifies the moment when the content of this feed has been
        /// created (in server time). In POSIX time (i.e., number of seconds since
        /// January 1st 1970 00:00:00 UTC).
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public ulong Timestamp
        {
            get { if ((_hasBits0 & 2) != 0) { return timestamp_; } else { return TimestampDefaultValue; } }
            set
            {
                _hasBits0 |= 2;
                timestamp_ = value;
            }
        }
        /// <summary>Gets whether the "timestamp" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasTimestamp
        {
            get { return (_hasBits0 & 2) != 0; }
        }
        /// <summary>Clears the value of the "timestamp" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearTimestamp()
        {
            _hasBits0 &= ~2;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other)
        {
            return Equals(other as FeedHeader);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(FeedHeader other)
        {
            if (ReferenceEquals(other, null))
            {
                return false;
            }
            if (ReferenceEquals(other, this))
            {
                return true;
            }
            if (GtfsRealtimeVersion != other.GtfsRealtimeVersion) return false;
            if (Incrementality != other.Incrementality) return false;
            if (Timestamp != other.Timestamp) return false;
            if (!Equals(_extensions, other._extensions))
            {
                return false;
            }
            return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode()
        {
            int hash = 1;
            if (HasGtfsRealtimeVersion) hash ^= GtfsRealtimeVersion.GetHashCode();
            if (HasIncrementality) hash ^= Incrementality.GetHashCode();
            if (HasTimestamp) hash ^= Timestamp.GetHashCode();
            if (_extensions != null)
            {
                hash ^= _extensions.GetHashCode();
            }
            if (_unknownFields != null)
            {
                hash ^= _unknownFields.GetHashCode();
            }
            return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString()
        {
            return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output)
        {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            output.WriteRawMessage(this);
#else
      if (HasGtfsRealtimeVersion) {
        output.WriteRawTag(10);
        output.WriteString(GtfsRealtimeVersion);
      }
      if (HasIncrementality) {
        output.WriteRawTag(16);
        output.WriteEnum((int) Incrementality);
      }
      if (HasTimestamp) {
        output.WriteRawTag(24);
        output.WriteUInt64(Timestamp);
      }
      if (_extensions != null) {
        _extensions.WriteTo(output);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
#endif
        }

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output)
        {
            if (HasGtfsRealtimeVersion)
            {
                output.WriteRawTag(10);
                output.WriteString(GtfsRealtimeVersion);
            }
            if (HasIncrementality)
            {
                output.WriteRawTag(16);
                output.WriteEnum((int)Incrementality);
            }
            if (HasTimestamp)
            {
                output.WriteRawTag(24);
                output.WriteUInt64(Timestamp);
            }
            if (_extensions != null)
            {
                _extensions.WriteTo(ref output);
            }
            if (_unknownFields != null)
            {
                _unknownFields.WriteTo(ref output);
            }
        }
#endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize()
        {
            int size = 0;
            if (HasGtfsRealtimeVersion)
            {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(GtfsRealtimeVersion);
            }
            if (HasIncrementality)
            {
                size += 1 + pb::CodedOutputStream.ComputeEnumSize((int)Incrementality);
            }
            if (HasTimestamp)
            {
                size += 1 + pb::CodedOutputStream.ComputeUInt64Size(Timestamp);
            }
            if (_extensions != null)
            {
                size += _extensions.CalculateSize();
            }
            if (_unknownFields != null)
            {
                size += _unknownFields.CalculateSize();
            }
            return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(FeedHeader other)
        {
            if (other == null)
            {
                return;
            }
            if (other.HasGtfsRealtimeVersion)
            {
                GtfsRealtimeVersion = other.GtfsRealtimeVersion;
            }
            if (other.HasIncrementality)
            {
                Incrementality = other.Incrementality;
            }
            if (other.HasTimestamp)
            {
                Timestamp = other.Timestamp;
            }
            pb::ExtensionSet.MergeFrom(ref _extensions, other._extensions);
            _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input)
        {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            input.ReadRawMessage(this);
#else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            if (!pb::ExtensionSet.TryMergeFieldFrom(ref _extensions, input)) {
              _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            }
            break;
          case 10: {
            GtfsRealtimeVersion = input.ReadString();
            break;
          }
          case 16: {
            Incrementality = (global::TransitRealtime.FeedHeader.Types.Incrementality) input.ReadEnum();
            break;
          }
          case 24: {
            Timestamp = input.ReadUInt64();
            break;
          }
        }
      }
#endif
        }

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input)
        {
            uint tag;
            while ((tag = input.ReadTag()) != 0)
            {
                switch (tag)
                {
                    default:
                        if (!pb::ExtensionSet.TryMergeFieldFrom(ref _extensions, ref input))
                        {
                            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                        }
                        break;
                    case 10:
                        {
                            GtfsRealtimeVersion = input.ReadString();
                            break;
                        }
                    case 16:
                        {
                            Incrementality = (global::STM.ExternalServiceProvider.Proto.FeedHeader.Types.Incrementality)input.ReadEnum();
                            break;
                        }
                    case 24:
                        {
                            Timestamp = input.ReadUInt64();
                            break;
                        }
                }
            }
        }
#endif

        public TValue GetExtension<TValue>(pb::Extension<FeedHeader, TValue> extension)
        {
            return pb::ExtensionSet.Get(ref _extensions, extension);
        }
        public pbc::RepeatedField<TValue> GetExtension<TValue>(pb::RepeatedExtension<FeedHeader, TValue> extension)
        {
            return pb::ExtensionSet.Get(ref _extensions, extension);
        }
        public pbc::RepeatedField<TValue> GetOrInitializeExtension<TValue>(pb::RepeatedExtension<FeedHeader, TValue> extension)
        {
            return pb::ExtensionSet.GetOrInitialize(ref _extensions, extension);
        }
        public void SetExtension<TValue>(pb::Extension<FeedHeader, TValue> extension, TValue value)
        {
            pb::ExtensionSet.Set(ref _extensions, extension, value);
        }
        public bool HasExtension<TValue>(pb::Extension<FeedHeader, TValue> extension)
        {
            return pb::ExtensionSet.Has(ref _extensions, extension);
        }
        public void ClearExtension<TValue>(pb::Extension<FeedHeader, TValue> extension)
        {
            pb::ExtensionSet.Clear(ref _extensions, extension);
        }
        public void ClearExtension<TValue>(pb::RepeatedExtension<FeedHeader, TValue> extension)
        {
            pb::ExtensionSet.Clear(ref _extensions, extension);
        }

        #region Nested types
        /// <summary>Container for nested types declared in the FeedHeader message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static partial class Types
        {
            /// <summary>
            /// Determines whether the current fetch is incremental.  Currently,
            /// DIFFERENTIAL mode is unsupported and behavior is unspecified for feeds
            /// that use this mode.  There are discussions on the GTFS Realtime mailing
            /// list around fully specifying the behavior of DIFFERENTIAL mode and the
            /// documentation will be updated when those discussions are finalized.
            /// </summary>
            public enum Incrementality
            {
                [pbr::OriginalName("FULL_DATASET")] FullDataset = 0,
                [pbr::OriginalName("DIFFERENTIAL")] Differential = 1,
            }

        }
        #endregion

    }

    /// <summary>
    /// A definition (or update) of an entity in the transit feed.
    /// </summary>
    public sealed partial class FeedEntity : pb::IExtendableMessage<FeedEntity>
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
#endif
    {
        private static readonly pb::MessageParser<FeedEntity> _parser = new pb::MessageParser<FeedEntity>(() => new FeedEntity());
        private pb::UnknownFieldSet _unknownFields;
        private pb::ExtensionSet<FeedEntity> _extensions;
        private pb::ExtensionSet<FeedEntity> _Extensions { get { return _extensions; } }
        private int _hasBits0;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<FeedEntity> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor
        {
            get { return global::STM.ExternalServiceProvider.Proto.GtfsRealtimeReflection.Descriptor.MessageTypes[2]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor
        {
            get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public FeedEntity()
        {
            OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public FeedEntity(FeedEntity other) : this()
        {
            _hasBits0 = other._hasBits0;
            id_ = other.id_;
            isDeleted_ = other.isDeleted_;
            tripUpdate_ = other.tripUpdate_ != null ? other.tripUpdate_.Clone() : null;
            vehicle_ = other.vehicle_ != null ? other.vehicle_.Clone() : null;
            alert_ = other.alert_ != null ? other.alert_.Clone() : null;
            _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            _extensions = pb::ExtensionSet.Clone(other._extensions);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public FeedEntity Clone()
        {
            return new FeedEntity(this);
        }

        /// <summary>Field number for the "id" field.</summary>
        public const int IdFieldNumber = 1;
        private readonly static string IdDefaultValue = "";

        private string id_;
        /// <summary>
        /// The ids are used only to provide incrementality support. The id should be
        /// unique within a FeedMessage. Consequent FeedMessages may contain
        /// FeedEntities with the same id. In case of a DIFFERENTIAL update the new
        /// FeedEntity with some id will replace the old FeedEntity with the same id
        /// (or delete it - see is_deleted below).
        /// The actual GTFS entities (e.g. stations, routes, trips) referenced by the
        /// feed must be specified by explicit selectors (see EntitySelector below for
        /// more info).
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public string Id
        {
            get { return id_ ?? IdDefaultValue; }
            set
            {
                id_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
            }
        }
        /// <summary>Gets whether the "id" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasId
        {
            get { return id_ != null; }
        }
        /// <summary>Clears the value of the "id" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearId()
        {
            id_ = null;
        }

        /// <summary>Field number for the "is_deleted" field.</summary>
        public const int IsDeletedFieldNumber = 2;
        private readonly static bool IsDeletedDefaultValue = false;

        private bool isDeleted_;
        /// <summary>
        /// Whether this entity is to be deleted. Relevant only for incremental
        /// fetches.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool IsDeleted
        {
            get { if ((_hasBits0 & 1) != 0) { return isDeleted_; } else { return IsDeletedDefaultValue; } }
            set
            {
                _hasBits0 |= 1;
                isDeleted_ = value;
            }
        }
        /// <summary>Gets whether the "is_deleted" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasIsDeleted
        {
            get { return (_hasBits0 & 1) != 0; }
        }
        /// <summary>Clears the value of the "is_deleted" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearIsDeleted()
        {
            _hasBits0 &= ~1;
        }

        /// <summary>Field number for the "trip_update" field.</summary>
        public const int TripUpdateFieldNumber = 3;
        private global::STM.ExternalServiceProvider.Proto.TripUpdate tripUpdate_;
        /// <summary>
        /// Data about the entity itself. Exactly one of the following fields must be
        /// present (unless the entity is being deleted).
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::STM.ExternalServiceProvider.Proto.TripUpdate TripUpdate
        {
            get { return tripUpdate_; }
            set
            {
                tripUpdate_ = value;
            }
        }

        /// <summary>Field number for the "vehicle" field.</summary>
        public const int VehicleFieldNumber = 4;
        private global::STM.ExternalServiceProvider.Proto.VehiclePosition vehicle_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::STM.ExternalServiceProvider.Proto.VehiclePosition Vehicle
        {
            get { return vehicle_; }
            set
            {
                vehicle_ = value;
            }
        }

        /// <summary>Field number for the "alert" field.</summary>
        public const int AlertFieldNumber = 5;
        private global::STM.ExternalServiceProvider.Proto.Alert alert_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::STM.ExternalServiceProvider.Proto.Alert Alert
        {
            get { return alert_; }
            set
            {
                alert_ = value;
            }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other)
        {
            return Equals(other as FeedEntity);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(FeedEntity other)
        {
            if (ReferenceEquals(other, null))
            {
                return false;
            }
            if (ReferenceEquals(other, this))
            {
                return true;
            }
            if (Id != other.Id) return false;
            if (IsDeleted != other.IsDeleted) return false;
            if (!object.Equals(TripUpdate, other.TripUpdate)) return false;
            if (!object.Equals(Vehicle, other.Vehicle)) return false;
            if (!object.Equals(Alert, other.Alert)) return false;
            if (!Equals(_extensions, other._extensions))
            {
                return false;
            }
            return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode()
        {
            int hash = 1;
            if (HasId) hash ^= Id.GetHashCode();
            if (HasIsDeleted) hash ^= IsDeleted.GetHashCode();
            if (tripUpdate_ != null) hash ^= TripUpdate.GetHashCode();
            if (vehicle_ != null) hash ^= Vehicle.GetHashCode();
            if (alert_ != null) hash ^= Alert.GetHashCode();
            if (_extensions != null)
            {
                hash ^= _extensions.GetHashCode();
            }
            if (_unknownFields != null)
            {
                hash ^= _unknownFields.GetHashCode();
            }
            return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString()
        {
            return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output)
        {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            output.WriteRawMessage(this);
#else
      if (HasId) {
        output.WriteRawTag(10);
        output.WriteString(Id);
      }
      if (HasIsDeleted) {
        output.WriteRawTag(16);
        output.WriteBool(IsDeleted);
      }
      if (tripUpdate_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(TripUpdate);
      }
      if (vehicle_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(Vehicle);
      }
      if (alert_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(Alert);
      }
      if (_extensions != null) {
        _extensions.WriteTo(output);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
#endif
        }

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output)
        {
            if (HasId)
            {
                output.WriteRawTag(10);
                output.WriteString(Id);
            }
            if (HasIsDeleted)
            {
                output.WriteRawTag(16);
                output.WriteBool(IsDeleted);
            }
            if (tripUpdate_ != null)
            {
                output.WriteRawTag(26);
                output.WriteMessage(TripUpdate);
            }
            if (vehicle_ != null)
            {
                output.WriteRawTag(34);
                output.WriteMessage(Vehicle);
            }
            if (alert_ != null)
            {
                output.WriteRawTag(42);
                output.WriteMessage(Alert);
            }
            if (_extensions != null)
            {
                _extensions.WriteTo(ref output);
            }
            if (_unknownFields != null)
            {
                _unknownFields.WriteTo(ref output);
            }
        }
#endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize()
        {
            int size = 0;
            if (HasId)
            {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(Id);
            }
            if (HasIsDeleted)
            {
                size += 1 + 1;
            }
            if (tripUpdate_ != null)
            {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(TripUpdate);
            }
            if (vehicle_ != null)
            {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(Vehicle);
            }
            if (alert_ != null)
            {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(Alert);
            }
            if (_extensions != null)
            {
                size += _extensions.CalculateSize();
            }
            if (_unknownFields != null)
            {
                size += _unknownFields.CalculateSize();
            }
            return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(FeedEntity other)
        {
            if (other == null)
            {
                return;
            }
            if (other.HasId)
            {
                Id = other.Id;
            }
            if (other.HasIsDeleted)
            {
                IsDeleted = other.IsDeleted;
            }
            if (other.tripUpdate_ != null)
            {
                if (tripUpdate_ == null)
                {
                    TripUpdate = new global::STM.ExternalServiceProvider.Proto.TripUpdate();
                }
                TripUpdate.MergeFrom(other.TripUpdate);
            }
            if (other.vehicle_ != null)
            {
                if (vehicle_ == null)
                {
                    Vehicle = new global::STM.ExternalServiceProvider.Proto.VehiclePosition();
                }
                Vehicle.MergeFrom(other.Vehicle);
            }
            if (other.alert_ != null)
            {
                if (alert_ == null)
                {
                    Alert = new global::STM.ExternalServiceProvider.Proto.Alert();
                }
                Alert.MergeFrom(other.Alert);
            }
            pb::ExtensionSet.MergeFrom(ref _extensions, other._extensions);
            _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input)
        {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            input.ReadRawMessage(this);
#else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            if (!pb::ExtensionSet.TryMergeFieldFrom(ref _extensions, input)) {
              _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            }
            break;
          case 10: {
            Id = input.ReadString();
            break;
          }
          case 16: {
            IsDeleted = input.ReadBool();
            break;
          }
          case 26: {
            if (tripUpdate_ == null) {
              TripUpdate = new global::TransitRealtime.TripUpdate();
            }
            input.ReadMessage(TripUpdate);
            break;
          }
          case 34: {
            if (vehicle_ == null) {
              Vehicle = new global::TransitRealtime.VehiclePosition();
            }
            input.ReadMessage(Vehicle);
            break;
          }
          case 42: {
            if (alert_ == null) {
              Alert = new global::TransitRealtime.Alert();
            }
            input.ReadMessage(Alert);
            break;
          }
        }
      }
#endif
        }

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input)
        {
            uint tag;
            while ((tag = input.ReadTag()) != 0)
            {
                switch (tag)
                {
                    default:
                        if (!pb::ExtensionSet.TryMergeFieldFrom(ref _extensions, ref input))
                        {
                            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                        }
                        break;
                    case 10:
                        {
                            Id = input.ReadString();
                            break;
                        }
                    case 16:
                        {
                            IsDeleted = input.ReadBool();
                            break;
                        }
                    case 26:
                        {
                            if (tripUpdate_ == null)
                            {
                                TripUpdate = new global::STM.ExternalServiceProvider.Proto.TripUpdate();
                            }
                            input.ReadMessage(TripUpdate);
                            break;
                        }
                    case 34:
                        {
                            if (vehicle_ == null)
                            {
                                Vehicle = new global::STM.ExternalServiceProvider.Proto.VehiclePosition();
                            }
                            input.ReadMessage(Vehicle);
                            break;
                        }
                    case 42:
                        {
                            if (alert_ == null)
                            {
                                Alert = new global::STM.ExternalServiceProvider.Proto.Alert();
                            }
                            input.ReadMessage(Alert);
                            break;
                        }
                }
            }
        }
#endif

        public TValue GetExtension<TValue>(pb::Extension<FeedEntity, TValue> extension)
        {
            return pb::ExtensionSet.Get(ref _extensions, extension);
        }
        public pbc::RepeatedField<TValue> GetExtension<TValue>(pb::RepeatedExtension<FeedEntity, TValue> extension)
        {
            return pb::ExtensionSet.Get(ref _extensions, extension);
        }
        public pbc::RepeatedField<TValue> GetOrInitializeExtension<TValue>(pb::RepeatedExtension<FeedEntity, TValue> extension)
        {
            return pb::ExtensionSet.GetOrInitialize(ref _extensions, extension);
        }
        public void SetExtension<TValue>(pb::Extension<FeedEntity, TValue> extension, TValue value)
        {
            pb::ExtensionSet.Set(ref _extensions, extension, value);
        }
        public bool HasExtension<TValue>(pb::Extension<FeedEntity, TValue> extension)
        {
            return pb::ExtensionSet.Has(ref _extensions, extension);
        }
        public void ClearExtension<TValue>(pb::Extension<FeedEntity, TValue> extension)
        {
            pb::ExtensionSet.Clear(ref _extensions, extension);
        }
        public void ClearExtension<TValue>(pb::RepeatedExtension<FeedEntity, TValue> extension)
        {
            pb::ExtensionSet.Clear(ref _extensions, extension);
        }

    }

    /// <summary>
    /// Realtime update of the progress of a vehicle along a trip.
    /// Depending on the value of ScheduleRelationship, a TripUpdate can specify:
    /// - A trip that proceeds along the schedule.
    /// - A trip that proceeds along a route but has no fixed schedule.
    /// - A trip that have been added or removed with regard to schedule.
    ///
    /// The updates can be for future, predicted arrival/departure events, or for
    /// past events that already occurred.
    /// Normally, updates should get more precise and more certain (see
    /// uncertainty below) as the events gets closer to current time.
    /// Even if that is not possible, the information for past events should be
    /// precise and certain. In particular, if an update points to time in the past
    /// but its update's uncertainty is not 0, the client should conclude that the
    /// update is a (wrong) prediction and that the trip has not completed yet.
    ///
    /// Note that the update can describe a trip that is already completed.
    /// To this end, it is enough to provide an update for the last stop of the trip.
    /// If the time of that is in the past, the client will conclude from that that
    /// the whole trip is in the past (it is possible, although inconsequential, to
    /// also provide updates for preceding stops).
    /// This option is most relevant for a trip that has completed ahead of schedule,
    /// but according to the schedule, the trip is still proceeding at the current
    /// time. Removing the updates for this trip could make the client assume
    /// that the trip is still proceeding.
    /// Note that the feed provider is allowed, but not required, to purge past
    /// updates - this is one case where this would be practically useful.
    /// </summary>
    public sealed partial class TripUpdate : pb::IExtendableMessage<TripUpdate>
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
#endif
    {
        private static readonly pb::MessageParser<TripUpdate> _parser = new pb::MessageParser<TripUpdate>(() => new TripUpdate());
        private pb::UnknownFieldSet _unknownFields;
        private pb::ExtensionSet<TripUpdate> _extensions;
        private pb::ExtensionSet<TripUpdate> _Extensions { get { return _extensions; } }
        private int _hasBits0;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<TripUpdate> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor
        {
            get { return global::STM.ExternalServiceProvider.Proto.GtfsRealtimeReflection.Descriptor.MessageTypes[3]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor
        {
            get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public TripUpdate()
        {
            OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public TripUpdate(TripUpdate other) : this()
        {
            _hasBits0 = other._hasBits0;
            trip_ = other.trip_ != null ? other.trip_.Clone() : null;
            vehicle_ = other.vehicle_ != null ? other.vehicle_.Clone() : null;
            stopTimeUpdate_ = other.stopTimeUpdate_.Clone();
            timestamp_ = other.timestamp_;
            delay_ = other.delay_;
            _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            _extensions = pb::ExtensionSet.Clone(other._extensions);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public TripUpdate Clone()
        {
            return new TripUpdate(this);
        }

        /// <summary>Field number for the "trip" field.</summary>
        public const int TripFieldNumber = 1;
        private global::STM.ExternalServiceProvider.Proto.TripDescriptor trip_;
        /// <summary>
        /// The Ride that this message applies to. There can be at most one
        /// TripUpdate entity for each actual trip instance.
        /// If there is none, that means there is no prediction information available.
        /// It does *not* mean that the trip is progressing according to schedule.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::STM.ExternalServiceProvider.Proto.TripDescriptor Trip
        {
            get { return trip_; }
            set
            {
                trip_ = value;
            }
        }

        /// <summary>Field number for the "vehicle" field.</summary>
        public const int VehicleFieldNumber = 3;
        private global::STM.ExternalServiceProvider.Proto.VehicleDescriptor vehicle_;
        /// <summary>
        /// Additional information on the vehicle that is serving this trip.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::STM.ExternalServiceProvider.Proto.VehicleDescriptor Vehicle
        {
            get { return vehicle_; }
            set
            {
                vehicle_ = value;
            }
        }

        /// <summary>Field number for the "stop_time_update" field.</summary>
        public const int StopTimeUpdateFieldNumber = 2;
        private static readonly pb::FieldCodec<global::STM.ExternalServiceProvider.Proto.TripUpdate.Types.StopTimeUpdate> _repeated_stopTimeUpdate_codec
            = pb::FieldCodec.ForMessage(18, global::STM.ExternalServiceProvider.Proto.TripUpdate.Types.StopTimeUpdate.Parser);
        private readonly pbc::RepeatedField<global::STM.ExternalServiceProvider.Proto.TripUpdate.Types.StopTimeUpdate> stopTimeUpdate_ = new pbc::RepeatedField<global::STM.ExternalServiceProvider.Proto.TripUpdate.Types.StopTimeUpdate>();
        /// <summary>
        /// Updates to StopTimes for the trip (both future, i.e., predictions, and in
        /// some cases, past ones, i.e., those that already happened).
        /// The updates must be sorted by stop_sequence, and apply for all the
        /// following stops of the trip up to the next specified one.
        ///
        /// Example 1:
        /// For a trip with 20 stops, a StopTimeUpdate with arrival delay and departure
        /// delay of 0 for stop_sequence of the current stop means that the trip is
        /// exactly on time.
        ///
        /// Example 2:
        /// For the same trip instance, 3 StopTimeUpdates are provided:
        /// - delay of 5 min for stop_sequence 3
        /// - delay of 1 min for stop_sequence 8
        /// - delay of unspecified duration for stop_sequence 10
        /// This will be interpreted as:
        /// - stop_sequences 3,4,5,6,7 have delay of 5 min.
        /// - stop_sequences 8,9 have delay of 1 min.
        /// - stop_sequences 10,... have unknown delay.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public pbc::RepeatedField<global::STM.ExternalServiceProvider.Proto.TripUpdate.Types.StopTimeUpdate> StopTimeUpdate
        {
            get { return stopTimeUpdate_; }
        }

        /// <summary>Field number for the "timestamp" field.</summary>
        public const int TimestampFieldNumber = 4;
        private readonly static ulong TimestampDefaultValue = 0UL;

        private ulong timestamp_;
        /// <summary>
        /// Moment at which the vehicle's real-time progress was measured. In POSIX
        /// time (i.e., the number of seconds since January 1st 1970 00:00:00 UTC).
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public ulong Timestamp
        {
            get { if ((_hasBits0 & 1) != 0) { return timestamp_; } else { return TimestampDefaultValue; } }
            set
            {
                _hasBits0 |= 1;
                timestamp_ = value;
            }
        }
        /// <summary>Gets whether the "timestamp" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasTimestamp
        {
            get { return (_hasBits0 & 1) != 0; }
        }
        /// <summary>Clears the value of the "timestamp" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearTimestamp()
        {
            _hasBits0 &= ~1;
        }

        /// <summary>Field number for the "delay" field.</summary>
        public const int DelayFieldNumber = 5;
        private readonly static int DelayDefaultValue = 0;

        private int delay_;
        /// <summary>
        /// The current schedule deviation for the trip.  Delay should only be
        /// specified when the prediction is given relative to some existing schedule
        /// in GTFS.
        ///
        /// Delay (in seconds) can be positive (meaning that the vehicle is late) or
        /// negative (meaning that the vehicle is ahead of schedule). Delay of 0
        /// means that the vehicle is exactly on time.
        ///
        /// Delay information in StopTimeUpdates take precedent of trip-level delay
        /// information, such that trip-level delay is only propagated until the next
        /// stop along the trip with a StopTimeUpdate delay value specified.
        ///
        /// Feed providers are strongly encouraged to provide a TripUpdate.timestamp
        /// value indicating when the delay value was last updated, in order to
        /// evaluate the freshness of the data.
        ///
        /// NOTE: This field is still experimental, and subject to change. It may be
        /// formally adopted in the future.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int Delay
        {
            get { if ((_hasBits0 & 2) != 0) { return delay_; } else { return DelayDefaultValue; } }
            set
            {
                _hasBits0 |= 2;
                delay_ = value;
            }
        }
        /// <summary>Gets whether the "delay" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasDelay
        {
            get { return (_hasBits0 & 2) != 0; }
        }
        /// <summary>Clears the value of the "delay" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearDelay()
        {
            _hasBits0 &= ~2;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other)
        {
            return Equals(other as TripUpdate);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(TripUpdate other)
        {
            if (ReferenceEquals(other, null))
            {
                return false;
            }
            if (ReferenceEquals(other, this))
            {
                return true;
            }
            if (!object.Equals(Trip, other.Trip)) return false;
            if (!object.Equals(Vehicle, other.Vehicle)) return false;
            if (!stopTimeUpdate_.Equals(other.stopTimeUpdate_)) return false;
            if (Timestamp != other.Timestamp) return false;
            if (Delay != other.Delay) return false;
            if (!Equals(_extensions, other._extensions))
            {
                return false;
            }
            return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode()
        {
            int hash = 1;
            if (trip_ != null) hash ^= Trip.GetHashCode();
            if (vehicle_ != null) hash ^= Vehicle.GetHashCode();
            hash ^= stopTimeUpdate_.GetHashCode();
            if (HasTimestamp) hash ^= Timestamp.GetHashCode();
            if (HasDelay) hash ^= Delay.GetHashCode();
            if (_extensions != null)
            {
                hash ^= _extensions.GetHashCode();
            }
            if (_unknownFields != null)
            {
                hash ^= _unknownFields.GetHashCode();
            }
            return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString()
        {
            return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output)
        {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            output.WriteRawMessage(this);
#else
      if (trip_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Ride);
      }
      stopTimeUpdate_.WriteTo(output, _repeated_stopTimeUpdate_codec);
      if (vehicle_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Vehicle);
      }
      if (HasTimestamp) {
        output.WriteRawTag(32);
        output.WriteUInt64(Timestamp);
      }
      if (HasDelay) {
        output.WriteRawTag(40);
        output.WriteInt32(Delay);
      }
      if (_extensions != null) {
        _extensions.WriteTo(output);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
#endif
        }

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output)
        {
            if (trip_ != null)
            {
                output.WriteRawTag(10);
                output.WriteMessage(Trip);
            }
            stopTimeUpdate_.WriteTo(ref output, _repeated_stopTimeUpdate_codec);
            if (vehicle_ != null)
            {
                output.WriteRawTag(26);
                output.WriteMessage(Vehicle);
            }
            if (HasTimestamp)
            {
                output.WriteRawTag(32);
                output.WriteUInt64(Timestamp);
            }
            if (HasDelay)
            {
                output.WriteRawTag(40);
                output.WriteInt32(Delay);
            }
            if (_extensions != null)
            {
                _extensions.WriteTo(ref output);
            }
            if (_unknownFields != null)
            {
                _unknownFields.WriteTo(ref output);
            }
        }
#endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize()
        {
            int size = 0;
            if (trip_ != null)
            {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(Trip);
            }
            if (vehicle_ != null)
            {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(Vehicle);
            }
            size += stopTimeUpdate_.CalculateSize(_repeated_stopTimeUpdate_codec);
            if (HasTimestamp)
            {
                size += 1 + pb::CodedOutputStream.ComputeUInt64Size(Timestamp);
            }
            if (HasDelay)
            {
                size += 1 + pb::CodedOutputStream.ComputeInt32Size(Delay);
            }
            if (_extensions != null)
            {
                size += _extensions.CalculateSize();
            }
            if (_unknownFields != null)
            {
                size += _unknownFields.CalculateSize();
            }
            return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(TripUpdate other)
        {
            if (other == null)
            {
                return;
            }
            if (other.trip_ != null)
            {
                if (trip_ == null)
                {
                    Trip = new global::STM.ExternalServiceProvider.Proto.TripDescriptor();
                }
                Trip.MergeFrom(other.Trip);
            }
            if (other.vehicle_ != null)
            {
                if (vehicle_ == null)
                {
                    Vehicle = new global::STM.ExternalServiceProvider.Proto.VehicleDescriptor();
                }
                Vehicle.MergeFrom(other.Vehicle);
            }
            stopTimeUpdate_.Add(other.stopTimeUpdate_);
            if (other.HasTimestamp)
            {
                Timestamp = other.Timestamp;
            }
            if (other.HasDelay)
            {
                Delay = other.Delay;
            }
            pb::ExtensionSet.MergeFrom(ref _extensions, other._extensions);
            _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input)
        {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            input.ReadRawMessage(this);
#else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            if (!pb::ExtensionSet.TryMergeFieldFrom(ref _extensions, input)) {
              _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            }
            break;
          case 10: {
            if (trip_ == null) {
              Ride = new global::TransitRealtime.TripDescriptor();
            }
            input.ReadMessage(Ride);
            break;
          }
          case 18: {
            stopTimeUpdate_.AddEntriesFrom(input, _repeated_stopTimeUpdate_codec);
            break;
          }
          case 26: {
            if (vehicle_ == null) {
              Vehicle = new global::TransitRealtime.VehicleDescriptor();
            }
            input.ReadMessage(Vehicle);
            break;
          }
          case 32: {
            Timestamp = input.ReadUInt64();
            break;
          }
          case 40: {
            Delay = input.ReadInt32();
            break;
          }
        }
      }
#endif
        }

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input)
        {
            uint tag;
            while ((tag = input.ReadTag()) != 0)
            {
                switch (tag)
                {
                    default:
                        if (!pb::ExtensionSet.TryMergeFieldFrom(ref _extensions, ref input))
                        {
                            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                        }
                        break;
                    case 10:
                        {
                            if (trip_ == null)
                            {
                                Trip = new global::STM.ExternalServiceProvider.Proto.TripDescriptor();
                            }
                            input.ReadMessage(Trip);
                            break;
                        }
                    case 18:
                        {
                            stopTimeUpdate_.AddEntriesFrom(ref input, _repeated_stopTimeUpdate_codec);
                            break;
                        }
                    case 26:
                        {
                            if (vehicle_ == null)
                            {
                                Vehicle = new global::STM.ExternalServiceProvider.Proto.VehicleDescriptor();
                            }
                            input.ReadMessage(Vehicle);
                            break;
                        }
                    case 32:
                        {
                            Timestamp = input.ReadUInt64();
                            break;
                        }
                    case 40:
                        {
                            Delay = input.ReadInt32();
                            break;
                        }
                }
            }
        }
#endif

        public TValue GetExtension<TValue>(pb::Extension<TripUpdate, TValue> extension)
        {
            return pb::ExtensionSet.Get(ref _extensions, extension);
        }
        public pbc::RepeatedField<TValue> GetExtension<TValue>(pb::RepeatedExtension<TripUpdate, TValue> extension)
        {
            return pb::ExtensionSet.Get(ref _extensions, extension);
        }
        public pbc::RepeatedField<TValue> GetOrInitializeExtension<TValue>(pb::RepeatedExtension<TripUpdate, TValue> extension)
        {
            return pb::ExtensionSet.GetOrInitialize(ref _extensions, extension);
        }
        public void SetExtension<TValue>(pb::Extension<TripUpdate, TValue> extension, TValue value)
        {
            pb::ExtensionSet.Set(ref _extensions, extension, value);
        }
        public bool HasExtension<TValue>(pb::Extension<TripUpdate, TValue> extension)
        {
            return pb::ExtensionSet.Has(ref _extensions, extension);
        }
        public void ClearExtension<TValue>(pb::Extension<TripUpdate, TValue> extension)
        {
            pb::ExtensionSet.Clear(ref _extensions, extension);
        }
        public void ClearExtension<TValue>(pb::RepeatedExtension<TripUpdate, TValue> extension)
        {
            pb::ExtensionSet.Clear(ref _extensions, extension);
        }

        #region Nested types
        /// <summary>Container for nested types declared in the TripUpdate message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static partial class Types
        {
            /// <summary>
            /// Timing information for a single predicted event (either arrival or
            /// departure).
            /// Timing consists of delay and/or estimated time, and uncertainty.
            /// - delay should be used when the prediction is given relative to some
            ///   existing schedule in GTFS.
            /// - time should be given whether there is a predicted schedule or not. If
            ///   both time and delay are specified, time will take precedence
            ///   (although normally, time, if given for a scheduled trip, should be
            ///   equal to scheduled time in GTFS + delay).
            ///
            /// Uncertainty applies equally to both time and delay.
            /// The uncertainty roughly specifies the expected error in true delay (but
            /// note, we don't yet define its precise statistical meaning). It's possible
            /// for the uncertainty to be 0, for example for trains that are driven under
            /// computer timing control.
            /// </summary>
            public sealed partial class StopTimeEvent : pb::IExtendableMessage<StopTimeEvent>
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
#endif
            {
                private static readonly pb::MessageParser<StopTimeEvent> _parser = new pb::MessageParser<StopTimeEvent>(() => new StopTimeEvent());
                private pb::UnknownFieldSet _unknownFields;
                private pb::ExtensionSet<StopTimeEvent> _extensions;
                private pb::ExtensionSet<StopTimeEvent> _Extensions { get { return _extensions; } }
                private int _hasBits0;
                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public static pb::MessageParser<StopTimeEvent> Parser { get { return _parser; } }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public static pbr::MessageDescriptor Descriptor
                {
                    get { return global::STM.ExternalServiceProvider.Proto.TripUpdate.Descriptor.NestedTypes[0]; }
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                pbr::MessageDescriptor pb::IMessage.Descriptor
                {
                    get { return Descriptor; }
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public StopTimeEvent()
                {
                    OnConstruction();
                }

                partial void OnConstruction();

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public StopTimeEvent(StopTimeEvent other) : this()
                {
                    _hasBits0 = other._hasBits0;
                    delay_ = other.delay_;
                    time_ = other.time_;
                    uncertainty_ = other.uncertainty_;
                    _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
                    _extensions = pb::ExtensionSet.Clone(other._extensions);
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public StopTimeEvent Clone()
                {
                    return new StopTimeEvent(this);
                }

                /// <summary>Field number for the "delay" field.</summary>
                public const int DelayFieldNumber = 1;
                private readonly static int DelayDefaultValue = 0;

                private int delay_;
                /// <summary>
                /// Delay (in seconds) can be positive (meaning that the vehicle is late) or
                /// negative (meaning that the vehicle is ahead of schedule). Delay of 0
                /// means that the vehicle is exactly on time.
                /// </summary>
                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public int Delay
                {
                    get { if ((_hasBits0 & 1) != 0) { return delay_; } else { return DelayDefaultValue; } }
                    set
                    {
                        _hasBits0 |= 1;
                        delay_ = value;
                    }
                }
                /// <summary>Gets whether the "delay" field is set</summary>
                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public bool HasDelay
                {
                    get { return (_hasBits0 & 1) != 0; }
                }
                /// <summary>Clears the value of the "delay" field</summary>
                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public void ClearDelay()
                {
                    _hasBits0 &= ~1;
                }

                /// <summary>Field number for the "time" field.</summary>
                public const int TimeFieldNumber = 2;
                private readonly static long TimeDefaultValue = 0L;

                private long time_;
                /// <summary>
                /// Event as absolute time.
                /// In Unix time (i.e., number of seconds since January 1st 1970 00:00:00
                /// UTC).
                /// </summary>
                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public long Time
                {
                    get { if ((_hasBits0 & 2) != 0) { return time_; } else { return TimeDefaultValue; } }
                    set
                    {
                        _hasBits0 |= 2;
                        time_ = value;
                    }
                }
                /// <summary>Gets whether the "time" field is set</summary>
                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public bool HasTime
                {
                    get { return (_hasBits0 & 2) != 0; }
                }
                /// <summary>Clears the value of the "time" field</summary>
                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public void ClearTime()
                {
                    _hasBits0 &= ~2;
                }

                /// <summary>Field number for the "uncertainty" field.</summary>
                public const int UncertaintyFieldNumber = 3;
                private readonly static int UncertaintyDefaultValue = 0;

                private int uncertainty_;
                /// <summary>
                /// If uncertainty is omitted, it is interpreted as unknown.
                /// If the prediction is unknown or too uncertain, the delay (or time) field
                /// should be empty. In such case, the uncertainty field is ignored.
                /// To specify a completely certain prediction, set its uncertainty to 0.
                /// </summary>
                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public int Uncertainty
                {
                    get { if ((_hasBits0 & 4) != 0) { return uncertainty_; } else { return UncertaintyDefaultValue; } }
                    set
                    {
                        _hasBits0 |= 4;
                        uncertainty_ = value;
                    }
                }
                /// <summary>Gets whether the "uncertainty" field is set</summary>
                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public bool HasUncertainty
                {
                    get { return (_hasBits0 & 4) != 0; }
                }
                /// <summary>Clears the value of the "uncertainty" field</summary>
                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public void ClearUncertainty()
                {
                    _hasBits0 &= ~4;
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public override bool Equals(object other)
                {
                    return Equals(other as StopTimeEvent);
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public bool Equals(StopTimeEvent other)
                {
                    if (ReferenceEquals(other, null))
                    {
                        return false;
                    }
                    if (ReferenceEquals(other, this))
                    {
                        return true;
                    }
                    if (Delay != other.Delay) return false;
                    if (Time != other.Time) return false;
                    if (Uncertainty != other.Uncertainty) return false;
                    if (!Equals(_extensions, other._extensions))
                    {
                        return false;
                    }
                    return Equals(_unknownFields, other._unknownFields);
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public override int GetHashCode()
                {
                    int hash = 1;
                    if (HasDelay) hash ^= Delay.GetHashCode();
                    if (HasTime) hash ^= Time.GetHashCode();
                    if (HasUncertainty) hash ^= Uncertainty.GetHashCode();
                    if (_extensions != null)
                    {
                        hash ^= _extensions.GetHashCode();
                    }
                    if (_unknownFields != null)
                    {
                        hash ^= _unknownFields.GetHashCode();
                    }
                    return hash;
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public override string ToString()
                {
                    return pb::JsonFormatter.ToDiagnosticString(this);
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public void WriteTo(pb::CodedOutputStream output)
                {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
                    output.WriteRawMessage(this);
#else
          if (HasDelay) {
            output.WriteRawTag(8);
            output.WriteInt32(Delay);
          }
          if (HasTime) {
            output.WriteRawTag(16);
            output.WriteInt64(Time);
          }
          if (HasUncertainty) {
            output.WriteRawTag(24);
            output.WriteInt32(Uncertainty);
          }
          if (_extensions != null) {
            _extensions.WriteTo(output);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
#endif
                }

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output)
                {
                    if (HasDelay)
                    {
                        output.WriteRawTag(8);
                        output.WriteInt32(Delay);
                    }
                    if (HasTime)
                    {
                        output.WriteRawTag(16);
                        output.WriteInt64(Time);
                    }
                    if (HasUncertainty)
                    {
                        output.WriteRawTag(24);
                        output.WriteInt32(Uncertainty);
                    }
                    if (_extensions != null)
                    {
                        _extensions.WriteTo(ref output);
                    }
                    if (_unknownFields != null)
                    {
                        _unknownFields.WriteTo(ref output);
                    }
                }
#endif

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public int CalculateSize()
                {
                    int size = 0;
                    if (HasDelay)
                    {
                        size += 1 + pb::CodedOutputStream.ComputeInt32Size(Delay);
                    }
                    if (HasTime)
                    {
                        size += 1 + pb::CodedOutputStream.ComputeInt64Size(Time);
                    }
                    if (HasUncertainty)
                    {
                        size += 1 + pb::CodedOutputStream.ComputeInt32Size(Uncertainty);
                    }
                    if (_extensions != null)
                    {
                        size += _extensions.CalculateSize();
                    }
                    if (_unknownFields != null)
                    {
                        size += _unknownFields.CalculateSize();
                    }
                    return size;
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public void MergeFrom(StopTimeEvent other)
                {
                    if (other == null)
                    {
                        return;
                    }
                    if (other.HasDelay)
                    {
                        Delay = other.Delay;
                    }
                    if (other.HasTime)
                    {
                        Time = other.Time;
                    }
                    if (other.HasUncertainty)
                    {
                        Uncertainty = other.Uncertainty;
                    }
                    pb::ExtensionSet.MergeFrom(ref _extensions, other._extensions);
                    _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public void MergeFrom(pb::CodedInputStream input)
                {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
                    input.ReadRawMessage(this);
#else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                if (!pb::ExtensionSet.TryMergeFieldFrom(ref _extensions, input)) {
                  _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                }
                break;
              case 8: {
                Delay = input.ReadInt32();
                break;
              }
              case 16: {
                Time = input.ReadInt64();
                break;
              }
              case 24: {
                Uncertainty = input.ReadInt32();
                break;
              }
            }
          }
#endif
                }

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input)
                {
                    uint tag;
                    while ((tag = input.ReadTag()) != 0)
                    {
                        switch (tag)
                        {
                            default:
                                if (!pb::ExtensionSet.TryMergeFieldFrom(ref _extensions, ref input))
                                {
                                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                                }
                                break;
                            case 8:
                                {
                                    Delay = input.ReadInt32();
                                    break;
                                }
                            case 16:
                                {
                                    Time = input.ReadInt64();
                                    break;
                                }
                            case 24:
                                {
                                    Uncertainty = input.ReadInt32();
                                    break;
                                }
                        }
                    }
                }
#endif

                public TValue GetExtension<TValue>(pb::Extension<StopTimeEvent, TValue> extension)
                {
                    return pb::ExtensionSet.Get(ref _extensions, extension);
                }
                public pbc::RepeatedField<TValue> GetExtension<TValue>(pb::RepeatedExtension<StopTimeEvent, TValue> extension)
                {
                    return pb::ExtensionSet.Get(ref _extensions, extension);
                }
                public pbc::RepeatedField<TValue> GetOrInitializeExtension<TValue>(pb::RepeatedExtension<StopTimeEvent, TValue> extension)
                {
                    return pb::ExtensionSet.GetOrInitialize(ref _extensions, extension);
                }
                public void SetExtension<TValue>(pb::Extension<StopTimeEvent, TValue> extension, TValue value)
                {
                    pb::ExtensionSet.Set(ref _extensions, extension, value);
                }
                public bool HasExtension<TValue>(pb::Extension<StopTimeEvent, TValue> extension)
                {
                    return pb::ExtensionSet.Has(ref _extensions, extension);
                }
                public void ClearExtension<TValue>(pb::Extension<StopTimeEvent, TValue> extension)
                {
                    pb::ExtensionSet.Clear(ref _extensions, extension);
                }
                public void ClearExtension<TValue>(pb::RepeatedExtension<StopTimeEvent, TValue> extension)
                {
                    pb::ExtensionSet.Clear(ref _extensions, extension);
                }

            }

            /// <summary>
            /// Realtime update for arrival and/or departure events for a given stop on a
            /// trip. Updates can be supplied for both past and future events.
            /// The producer is allowed, although not required, to drop past events.
            /// </summary>
            public sealed partial class StopTimeUpdate : pb::IExtendableMessage<StopTimeUpdate>
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
#endif
            {
                private static readonly pb::MessageParser<StopTimeUpdate> _parser = new pb::MessageParser<StopTimeUpdate>(() => new StopTimeUpdate());
                private pb::UnknownFieldSet _unknownFields;
                private pb::ExtensionSet<StopTimeUpdate> _extensions;
                private pb::ExtensionSet<StopTimeUpdate> _Extensions { get { return _extensions; } }
                private int _hasBits0;
                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public static pb::MessageParser<StopTimeUpdate> Parser { get { return _parser; } }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public static pbr::MessageDescriptor Descriptor
                {
                    get { return global::STM.ExternalServiceProvider.Proto.TripUpdate.Descriptor.NestedTypes[1]; }
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                pbr::MessageDescriptor pb::IMessage.Descriptor
                {
                    get { return Descriptor; }
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public StopTimeUpdate()
                {
                    OnConstruction();
                }

                partial void OnConstruction();

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public StopTimeUpdate(StopTimeUpdate other) : this()
                {
                    _hasBits0 = other._hasBits0;
                    stopSequence_ = other.stopSequence_;
                    stopId_ = other.stopId_;
                    arrival_ = other.arrival_ != null ? other.arrival_.Clone() : null;
                    departure_ = other.departure_ != null ? other.departure_.Clone() : null;
                    scheduleRelationship_ = other.scheduleRelationship_;
                    _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
                    _extensions = pb::ExtensionSet.Clone(other._extensions);
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public StopTimeUpdate Clone()
                {
                    return new StopTimeUpdate(this);
                }

                /// <summary>Field number for the "stop_sequence" field.</summary>
                public const int StopSequenceFieldNumber = 1;
                private readonly static uint StopSequenceDefaultValue = 0;

                private uint stopSequence_;
                /// <summary>
                /// Must be the same as in stop_times.txt in the corresponding GTFS feed.
                /// </summary>
                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public uint StopSequence
                {
                    get { if ((_hasBits0 & 1) != 0) { return stopSequence_; } else { return StopSequenceDefaultValue; } }
                    set
                    {
                        _hasBits0 |= 1;
                        stopSequence_ = value;
                    }
                }
                /// <summary>Gets whether the "stop_sequence" field is set</summary>
                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public bool HasStopSequence
                {
                    get { return (_hasBits0 & 1) != 0; }
                }
                /// <summary>Clears the value of the "stop_sequence" field</summary>
                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public void ClearStopSequence()
                {
                    _hasBits0 &= ~1;
                }

                /// <summary>Field number for the "stop_id" field.</summary>
                public const int StopIdFieldNumber = 4;
                private readonly static string StopIdDefaultValue = "";

                private string stopId_;
                /// <summary>
                /// Must be the same as in stops.txt in the corresponding GTFS feed.
                /// </summary>
                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public string StopId
                {
                    get { return stopId_ ?? StopIdDefaultValue; }
                    set
                    {
                        stopId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
                    }
                }
                /// <summary>Gets whether the "stop_id" field is set</summary>
                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public bool HasStopId
                {
                    get { return stopId_ != null; }
                }
                /// <summary>Clears the value of the "stop_id" field</summary>
                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public void ClearStopId()
                {
                    stopId_ = null;
                }

                /// <summary>Field number for the "arrival" field.</summary>
                public const int ArrivalFieldNumber = 2;
                private global::STM.ExternalServiceProvider.Proto.TripUpdate.Types.StopTimeEvent arrival_;
                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public global::STM.ExternalServiceProvider.Proto.TripUpdate.Types.StopTimeEvent Arrival
                {
                    get { return arrival_; }
                    set
                    {
                        arrival_ = value;
                    }
                }

                /// <summary>Field number for the "departure" field.</summary>
                public const int DepartureFieldNumber = 3;
                private global::STM.ExternalServiceProvider.Proto.TripUpdate.Types.StopTimeEvent departure_;
                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public global::STM.ExternalServiceProvider.Proto.TripUpdate.Types.StopTimeEvent Departure
                {
                    get { return departure_; }
                    set
                    {
                        departure_ = value;
                    }
                }

                /// <summary>Field number for the "schedule_relationship" field.</summary>
                public const int ScheduleRelationshipFieldNumber = 5;
                private readonly static global::STM.ExternalServiceProvider.Proto.TripUpdate.Types.StopTimeUpdate.Types.ScheduleRelationship ScheduleRelationshipDefaultValue = global::STM.ExternalServiceProvider.Proto.TripUpdate.Types.StopTimeUpdate.Types.ScheduleRelationship.Scheduled;

                private global::STM.ExternalServiceProvider.Proto.TripUpdate.Types.StopTimeUpdate.Types.ScheduleRelationship scheduleRelationship_;
                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public global::STM.ExternalServiceProvider.Proto.TripUpdate.Types.StopTimeUpdate.Types.ScheduleRelationship ScheduleRelationship
                {
                    get { if ((_hasBits0 & 2) != 0) { return scheduleRelationship_; } else { return ScheduleRelationshipDefaultValue; } }
                    set
                    {
                        _hasBits0 |= 2;
                        scheduleRelationship_ = value;
                    }
                }
                /// <summary>Gets whether the "schedule_relationship" field is set</summary>
                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public bool HasScheduleRelationship
                {
                    get { return (_hasBits0 & 2) != 0; }
                }
                /// <summary>Clears the value of the "schedule_relationship" field</summary>
                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public void ClearScheduleRelationship()
                {
                    _hasBits0 &= ~2;
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public override bool Equals(object other)
                {
                    return Equals(other as StopTimeUpdate);
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public bool Equals(StopTimeUpdate other)
                {
                    if (ReferenceEquals(other, null))
                    {
                        return false;
                    }
                    if (ReferenceEquals(other, this))
                    {
                        return true;
                    }
                    if (StopSequence != other.StopSequence) return false;
                    if (StopId != other.StopId) return false;
                    if (!object.Equals(Arrival, other.Arrival)) return false;
                    if (!object.Equals(Departure, other.Departure)) return false;
                    if (ScheduleRelationship != other.ScheduleRelationship) return false;
                    if (!Equals(_extensions, other._extensions))
                    {
                        return false;
                    }
                    return Equals(_unknownFields, other._unknownFields);
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public override int GetHashCode()
                {
                    int hash = 1;
                    if (HasStopSequence) hash ^= StopSequence.GetHashCode();
                    if (HasStopId) hash ^= StopId.GetHashCode();
                    if (arrival_ != null) hash ^= Arrival.GetHashCode();
                    if (departure_ != null) hash ^= Departure.GetHashCode();
                    if (HasScheduleRelationship) hash ^= ScheduleRelationship.GetHashCode();
                    if (_extensions != null)
                    {
                        hash ^= _extensions.GetHashCode();
                    }
                    if (_unknownFields != null)
                    {
                        hash ^= _unknownFields.GetHashCode();
                    }
                    return hash;
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public override string ToString()
                {
                    return pb::JsonFormatter.ToDiagnosticString(this);
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public void WriteTo(pb::CodedOutputStream output)
                {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
                    output.WriteRawMessage(this);
#else
          if (HasStopSequence) {
            output.WriteRawTag(8);
            output.WriteUInt32(StopSequence);
          }
          if (arrival_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(Arrival);
          }
          if (departure_ != null) {
            output.WriteRawTag(26);
            output.WriteMessage(Departure);
          }
          if (HasStopId) {
            output.WriteRawTag(34);
            output.WriteString(StopId);
          }
          if (HasScheduleRelationship) {
            output.WriteRawTag(40);
            output.WriteEnum((int) ScheduleRelationship);
          }
          if (_extensions != null) {
            _extensions.WriteTo(output);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
#endif
                }

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output)
                {
                    if (HasStopSequence)
                    {
                        output.WriteRawTag(8);
                        output.WriteUInt32(StopSequence);
                    }
                    if (arrival_ != null)
                    {
                        output.WriteRawTag(18);
                        output.WriteMessage(Arrival);
                    }
                    if (departure_ != null)
                    {
                        output.WriteRawTag(26);
                        output.WriteMessage(Departure);
                    }
                    if (HasStopId)
                    {
                        output.WriteRawTag(34);
                        output.WriteString(StopId);
                    }
                    if (HasScheduleRelationship)
                    {
                        output.WriteRawTag(40);
                        output.WriteEnum((int)ScheduleRelationship);
                    }
                    if (_extensions != null)
                    {
                        _extensions.WriteTo(ref output);
                    }
                    if (_unknownFields != null)
                    {
                        _unknownFields.WriteTo(ref output);
                    }
                }
#endif

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public int CalculateSize()
                {
                    int size = 0;
                    if (HasStopSequence)
                    {
                        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(StopSequence);
                    }
                    if (HasStopId)
                    {
                        size += 1 + pb::CodedOutputStream.ComputeStringSize(StopId);
                    }
                    if (arrival_ != null)
                    {
                        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Arrival);
                    }
                    if (departure_ != null)
                    {
                        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Departure);
                    }
                    if (HasScheduleRelationship)
                    {
                        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int)ScheduleRelationship);
                    }
                    if (_extensions != null)
                    {
                        size += _extensions.CalculateSize();
                    }
                    if (_unknownFields != null)
                    {
                        size += _unknownFields.CalculateSize();
                    }
                    return size;
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public void MergeFrom(StopTimeUpdate other)
                {
                    if (other == null)
                    {
                        return;
                    }
                    if (other.HasStopSequence)
                    {
                        StopSequence = other.StopSequence;
                    }
                    if (other.HasStopId)
                    {
                        StopId = other.StopId;
                    }
                    if (other.arrival_ != null)
                    {
                        if (arrival_ == null)
                        {
                            Arrival = new global::STM.ExternalServiceProvider.Proto.TripUpdate.Types.StopTimeEvent();
                        }
                        Arrival.MergeFrom(other.Arrival);
                    }
                    if (other.departure_ != null)
                    {
                        if (departure_ == null)
                        {
                            Departure = new global::STM.ExternalServiceProvider.Proto.TripUpdate.Types.StopTimeEvent();
                        }
                        Departure.MergeFrom(other.Departure);
                    }
                    if (other.HasScheduleRelationship)
                    {
                        ScheduleRelationship = other.ScheduleRelationship;
                    }
                    pb::ExtensionSet.MergeFrom(ref _extensions, other._extensions);
                    _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public void MergeFrom(pb::CodedInputStream input)
                {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
                    input.ReadRawMessage(this);
#else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                if (!pb::ExtensionSet.TryMergeFieldFrom(ref _extensions, input)) {
                  _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                }
                break;
              case 8: {
                StopSequence = input.ReadUInt32();
                break;
              }
              case 18: {
                if (arrival_ == null) {
                  Arrival = new global::TransitRealtime.TripUpdate.Types.StopTimeEvent();
                }
                input.ReadMessage(Arrival);
                break;
              }
              case 26: {
                if (departure_ == null) {
                  Departure = new global::TransitRealtime.TripUpdate.Types.StopTimeEvent();
                }
                input.ReadMessage(Departure);
                break;
              }
              case 34: {
                StopId = input.ReadString();
                break;
              }
              case 40: {
                ScheduleRelationship = (global::TransitRealtime.TripUpdate.Types.StopTimeUpdate.Types.ScheduleRelationship) input.ReadEnum();
                break;
              }
            }
          }
#endif
                }

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input)
                {
                    uint tag;
                    while ((tag = input.ReadTag()) != 0)
                    {
                        switch (tag)
                        {
                            default:
                                if (!pb::ExtensionSet.TryMergeFieldFrom(ref _extensions, ref input))
                                {
                                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                                }
                                break;
                            case 8:
                                {
                                    StopSequence = input.ReadUInt32();
                                    break;
                                }
                            case 18:
                                {
                                    if (arrival_ == null)
                                    {
                                        Arrival = new global::STM.ExternalServiceProvider.Proto.TripUpdate.Types.StopTimeEvent();
                                    }
                                    input.ReadMessage(Arrival);
                                    break;
                                }
                            case 26:
                                {
                                    if (departure_ == null)
                                    {
                                        Departure = new global::STM.ExternalServiceProvider.Proto.TripUpdate.Types.StopTimeEvent();
                                    }
                                    input.ReadMessage(Departure);
                                    break;
                                }
                            case 34:
                                {
                                    StopId = input.ReadString();
                                    break;
                                }
                            case 40:
                                {
                                    ScheduleRelationship = (global::STM.ExternalServiceProvider.Proto.TripUpdate.Types.StopTimeUpdate.Types.ScheduleRelationship)input.ReadEnum();
                                    break;
                                }
                        }
                    }
                }
#endif

                public TValue GetExtension<TValue>(pb::Extension<StopTimeUpdate, TValue> extension)
                {
                    return pb::ExtensionSet.Get(ref _extensions, extension);
                }
                public pbc::RepeatedField<TValue> GetExtension<TValue>(pb::RepeatedExtension<StopTimeUpdate, TValue> extension)
                {
                    return pb::ExtensionSet.Get(ref _extensions, extension);
                }
                public pbc::RepeatedField<TValue> GetOrInitializeExtension<TValue>(pb::RepeatedExtension<StopTimeUpdate, TValue> extension)
                {
                    return pb::ExtensionSet.GetOrInitialize(ref _extensions, extension);
                }
                public void SetExtension<TValue>(pb::Extension<StopTimeUpdate, TValue> extension, TValue value)
                {
                    pb::ExtensionSet.Set(ref _extensions, extension, value);
                }
                public bool HasExtension<TValue>(pb::Extension<StopTimeUpdate, TValue> extension)
                {
                    return pb::ExtensionSet.Has(ref _extensions, extension);
                }
                public void ClearExtension<TValue>(pb::Extension<StopTimeUpdate, TValue> extension)
                {
                    pb::ExtensionSet.Clear(ref _extensions, extension);
                }
                public void ClearExtension<TValue>(pb::RepeatedExtension<StopTimeUpdate, TValue> extension)
                {
                    pb::ExtensionSet.Clear(ref _extensions, extension);
                }

                #region Nested types
                /// <summary>Container for nested types declared in the StopTimeUpdate message type.</summary>
                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public static partial class Types
                {
                    /// <summary>
                    /// The relation between this StopTime and the static schedule.
                    /// </summary>
                    public enum ScheduleRelationship
                    {
                        /// <summary>
                        /// The vehicle is proceeding in accordance with its static schedule of
                        /// stops, although not necessarily according to the times of the schedule.
                        /// At least one of arrival and departure must be provided. If the schedule
                        /// for this stop contains both arrival and departure times then so must
                        /// this update.
                        /// </summary>
                        [pbr::OriginalName("SCHEDULED")] Scheduled = 0,
                        /// <summary>
                        /// The stop is skipped, i.e., the vehicle will not stop at this stop.
                        /// Arrival and departure are optional.
                        /// </summary>
                        [pbr::OriginalName("SKIPPED")] Skipped = 1,
                        /// <summary>
                        /// No data is given for this stop. The main intention for this value is to
                        /// give the predictions only for part of a trip, i.e., if the last update
                        /// for a trip has a NO_DATA specifier, then StopTimes for the rest of the
                        /// stops in the trip are considered to be unspecified as well.
                        /// Neither arrival nor departure should be supplied.
                        /// </summary>
                        [pbr::OriginalName("NO_DATA")] NoData = 2,
                    }

                }
                #endregion

            }

        }
        #endregion

    }

    /// <summary>
    /// Realtime positioning information for a given vehicle.
    /// </summary>
    public sealed partial class VehiclePosition : pb::IExtendableMessage<VehiclePosition>
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
#endif
    {
        private static readonly pb::MessageParser<VehiclePosition> _parser = new pb::MessageParser<VehiclePosition>(() => new VehiclePosition());
        private pb::UnknownFieldSet _unknownFields;
        private pb::ExtensionSet<VehiclePosition> _extensions;
        private pb::ExtensionSet<VehiclePosition> _Extensions { get { return _extensions; } }
        private int _hasBits0;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<VehiclePosition> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor
        {
            get { return global::STM.ExternalServiceProvider.Proto.GtfsRealtimeReflection.Descriptor.MessageTypes[4]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor
        {
            get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public VehiclePosition()
        {
            OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public VehiclePosition(VehiclePosition other) : this()
        {
            _hasBits0 = other._hasBits0;
            trip_ = other.trip_ != null ? other.trip_.Clone() : null;
            vehicle_ = other.vehicle_ != null ? other.vehicle_.Clone() : null;
            position_ = other.position_ != null ? other.position_.Clone() : null;
            currentStopSequence_ = other.currentStopSequence_;
            stopId_ = other.stopId_;
            currentStatus_ = other.currentStatus_;
            timestamp_ = other.timestamp_;
            congestionLevel_ = other.congestionLevel_;
            occupancyStatus_ = other.occupancyStatus_;
            _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            _extensions = pb::ExtensionSet.Clone(other._extensions);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public VehiclePosition Clone()
        {
            return new VehiclePosition(this);
        }

        /// <summary>Field number for the "trip" field.</summary>
        public const int TripFieldNumber = 1;
        private global::STM.ExternalServiceProvider.Proto.TripDescriptor trip_;
        /// <summary>
        /// The Ride that this vehicle is serving.
        /// Can be empty or partial if the vehicle can not be identified with a given
        /// trip instance.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::STM.ExternalServiceProvider.Proto.TripDescriptor Trip
        {
            get { return trip_; }
            set
            {
                trip_ = value;
            }
        }

        /// <summary>Field number for the "vehicle" field.</summary>
        public const int VehicleFieldNumber = 8;
        private global::STM.ExternalServiceProvider.Proto.VehicleDescriptor vehicle_;
        /// <summary>
        /// Additional information on the vehicle that is serving this trip.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::STM.ExternalServiceProvider.Proto.VehicleDescriptor Vehicle
        {
            get { return vehicle_; }
            set
            {
                vehicle_ = value;
            }
        }

        /// <summary>Field number for the "position" field.</summary>
        public const int PositionFieldNumber = 2;
        private global::STM.ExternalServiceProvider.Proto.Position position_;
        /// <summary>
        /// Current position of this vehicle.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::STM.ExternalServiceProvider.Proto.Position Position
        {
            get { return position_; }
            set
            {
                position_ = value;
            }
        }

        /// <summary>Field number for the "current_stop_sequence" field.</summary>
        public const int CurrentStopSequenceFieldNumber = 3;
        private readonly static uint CurrentStopSequenceDefaultValue = 0;

        private uint currentStopSequence_;
        /// <summary>
        /// The stop sequence index of the current stop. The meaning of
        /// current_stop_sequence (i.e., the stop that it refers to) is determined by
        /// current_status.
        /// If current_status is missing IN_TRANSIT_TO is assumed.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public uint CurrentStopSequence
        {
            get { if ((_hasBits0 & 1) != 0) { return currentStopSequence_; } else { return CurrentStopSequenceDefaultValue; } }
            set
            {
                _hasBits0 |= 1;
                currentStopSequence_ = value;
            }
        }
        /// <summary>Gets whether the "current_stop_sequence" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasCurrentStopSequence
        {
            get { return (_hasBits0 & 1) != 0; }
        }
        /// <summary>Clears the value of the "current_stop_sequence" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearCurrentStopSequence()
        {
            _hasBits0 &= ~1;
        }

        /// <summary>Field number for the "stop_id" field.</summary>
        public const int StopIdFieldNumber = 7;
        private readonly static string StopIdDefaultValue = "";

        private string stopId_;
        /// <summary>
        /// Identifies the current stop. The value must be the same as in stops.txt in
        /// the corresponding GTFS feed.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public string StopId
        {
            get { return stopId_ ?? StopIdDefaultValue; }
            set
            {
                stopId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
            }
        }
        /// <summary>Gets whether the "stop_id" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasStopId
        {
            get { return stopId_ != null; }
        }
        /// <summary>Clears the value of the "stop_id" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearStopId()
        {
            stopId_ = null;
        }

        /// <summary>Field number for the "current_status" field.</summary>
        public const int CurrentStatusFieldNumber = 4;
        private readonly static global::STM.ExternalServiceProvider.Proto.VehiclePosition.Types.VehicleStopStatus CurrentStatusDefaultValue = global::STM.ExternalServiceProvider.Proto.VehiclePosition.Types.VehicleStopStatus.InTransitTo;

        private global::STM.ExternalServiceProvider.Proto.VehiclePosition.Types.VehicleStopStatus currentStatus_;
        /// <summary>
        /// The exact status of the vehicle with respect to the current stop.
        /// Ignored if current_stop_sequence is missing.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::STM.ExternalServiceProvider.Proto.VehiclePosition.Types.VehicleStopStatus CurrentStatus
        {
            get { if ((_hasBits0 & 2) != 0) { return currentStatus_; } else { return CurrentStatusDefaultValue; } }
            set
            {
                _hasBits0 |= 2;
                currentStatus_ = value;
            }
        }
        /// <summary>Gets whether the "current_status" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasCurrentStatus
        {
            get { return (_hasBits0 & 2) != 0; }
        }
        /// <summary>Clears the value of the "current_status" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearCurrentStatus()
        {
            _hasBits0 &= ~2;
        }

        /// <summary>Field number for the "timestamp" field.</summary>
        public const int TimestampFieldNumber = 5;
        private readonly static ulong TimestampDefaultValue = 0UL;

        private ulong timestamp_;
        /// <summary>
        /// Moment at which the vehicle's position was measured. In POSIX time
        /// (i.e., number of seconds since January 1st 1970 00:00:00 UTC).
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public ulong Timestamp
        {
            get { if ((_hasBits0 & 4) != 0) { return timestamp_; } else { return TimestampDefaultValue; } }
            set
            {
                _hasBits0 |= 4;
                timestamp_ = value;
            }
        }
        /// <summary>Gets whether the "timestamp" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasTimestamp
        {
            get { return (_hasBits0 & 4) != 0; }
        }
        /// <summary>Clears the value of the "timestamp" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearTimestamp()
        {
            _hasBits0 &= ~4;
        }

        /// <summary>Field number for the "congestion_level" field.</summary>
        public const int CongestionLevelFieldNumber = 6;
        private readonly static global::STM.ExternalServiceProvider.Proto.VehiclePosition.Types.CongestionLevel CongestionLevelDefaultValue = global::STM.ExternalServiceProvider.Proto.VehiclePosition.Types.CongestionLevel.UnknownCongestionLevel;

        private global::STM.ExternalServiceProvider.Proto.VehiclePosition.Types.CongestionLevel congestionLevel_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::STM.ExternalServiceProvider.Proto.VehiclePosition.Types.CongestionLevel CongestionLevel
        {
            get { if ((_hasBits0 & 8) != 0) { return congestionLevel_; } else { return CongestionLevelDefaultValue; } }
            set
            {
                _hasBits0 |= 8;
                congestionLevel_ = value;
            }
        }
        /// <summary>Gets whether the "congestion_level" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasCongestionLevel
        {
            get { return (_hasBits0 & 8) != 0; }
        }
        /// <summary>Clears the value of the "congestion_level" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearCongestionLevel()
        {
            _hasBits0 &= ~8;
        }

        /// <summary>Field number for the "occupancy_status" field.</summary>
        public const int OccupancyStatusFieldNumber = 9;
        private readonly static global::STM.ExternalServiceProvider.Proto.VehiclePosition.Types.OccupancyStatus OccupancyStatusDefaultValue = global::STM.ExternalServiceProvider.Proto.VehiclePosition.Types.OccupancyStatus.Empty;

        private global::STM.ExternalServiceProvider.Proto.VehiclePosition.Types.OccupancyStatus occupancyStatus_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::STM.ExternalServiceProvider.Proto.VehiclePosition.Types.OccupancyStatus OccupancyStatus
        {
            get { if ((_hasBits0 & 16) != 0) { return occupancyStatus_; } else { return OccupancyStatusDefaultValue; } }
            set
            {
                _hasBits0 |= 16;
                occupancyStatus_ = value;
            }
        }
        /// <summary>Gets whether the "occupancy_status" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasOccupancyStatus
        {
            get { return (_hasBits0 & 16) != 0; }
        }
        /// <summary>Clears the value of the "occupancy_status" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearOccupancyStatus()
        {
            _hasBits0 &= ~16;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other)
        {
            return Equals(other as VehiclePosition);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(VehiclePosition other)
        {
            if (ReferenceEquals(other, null))
            {
                return false;
            }
            if (ReferenceEquals(other, this))
            {
                return true;
            }
            if (!object.Equals(Trip, other.Trip)) return false;
            if (!object.Equals(Vehicle, other.Vehicle)) return false;
            if (!object.Equals(Position, other.Position)) return false;
            if (CurrentStopSequence != other.CurrentStopSequence) return false;
            if (StopId != other.StopId) return false;
            if (CurrentStatus != other.CurrentStatus) return false;
            if (Timestamp != other.Timestamp) return false;
            if (CongestionLevel != other.CongestionLevel) return false;
            if (OccupancyStatus != other.OccupancyStatus) return false;
            if (!Equals(_extensions, other._extensions))
            {
                return false;
            }
            return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode()
        {
            int hash = 1;
            if (trip_ != null) hash ^= Trip.GetHashCode();
            if (vehicle_ != null) hash ^= Vehicle.GetHashCode();
            if (position_ != null) hash ^= Position.GetHashCode();
            if (HasCurrentStopSequence) hash ^= CurrentStopSequence.GetHashCode();
            if (HasStopId) hash ^= StopId.GetHashCode();
            if (HasCurrentStatus) hash ^= CurrentStatus.GetHashCode();
            if (HasTimestamp) hash ^= Timestamp.GetHashCode();
            if (HasCongestionLevel) hash ^= CongestionLevel.GetHashCode();
            if (HasOccupancyStatus) hash ^= OccupancyStatus.GetHashCode();
            if (_extensions != null)
            {
                hash ^= _extensions.GetHashCode();
            }
            if (_unknownFields != null)
            {
                hash ^= _unknownFields.GetHashCode();
            }
            return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString()
        {
            return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output)
        {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            output.WriteRawMessage(this);
#else
      if (trip_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Ride);
      }
      if (position_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Position);
      }
      if (HasCurrentStopSequence) {
        output.WriteRawTag(24);
        output.WriteUInt32(CurrentStopSequence);
      }
      if (HasCurrentStatus) {
        output.WriteRawTag(32);
        output.WriteEnum((int) CurrentStatus);
      }
      if (HasTimestamp) {
        output.WriteRawTag(40);
        output.WriteUInt64(Timestamp);
      }
      if (HasCongestionLevel) {
        output.WriteRawTag(48);
        output.WriteEnum((int) CongestionLevel);
      }
      if (HasStopId) {
        output.WriteRawTag(58);
        output.WriteString(StopId);
      }
      if (vehicle_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(Vehicle);
      }
      if (HasOccupancyStatus) {
        output.WriteRawTag(72);
        output.WriteEnum((int) OccupancyStatus);
      }
      if (_extensions != null) {
        _extensions.WriteTo(output);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
#endif
        }

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output)
        {
            if (trip_ != null)
            {
                output.WriteRawTag(10);
                output.WriteMessage(Trip);
            }
            if (position_ != null)
            {
                output.WriteRawTag(18);
                output.WriteMessage(Position);
            }
            if (HasCurrentStopSequence)
            {
                output.WriteRawTag(24);
                output.WriteUInt32(CurrentStopSequence);
            }
            if (HasCurrentStatus)
            {
                output.WriteRawTag(32);
                output.WriteEnum((int)CurrentStatus);
            }
            if (HasTimestamp)
            {
                output.WriteRawTag(40);
                output.WriteUInt64(Timestamp);
            }
            if (HasCongestionLevel)
            {
                output.WriteRawTag(48);
                output.WriteEnum((int)CongestionLevel);
            }
            if (HasStopId)
            {
                output.WriteRawTag(58);
                output.WriteString(StopId);
            }
            if (vehicle_ != null)
            {
                output.WriteRawTag(66);
                output.WriteMessage(Vehicle);
            }
            if (HasOccupancyStatus)
            {
                output.WriteRawTag(72);
                output.WriteEnum((int)OccupancyStatus);
            }
            if (_extensions != null)
            {
                _extensions.WriteTo(ref output);
            }
            if (_unknownFields != null)
            {
                _unknownFields.WriteTo(ref output);
            }
        }
#endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize()
        {
            int size = 0;
            if (trip_ != null)
            {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(Trip);
            }
            if (vehicle_ != null)
            {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(Vehicle);
            }
            if (position_ != null)
            {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(Position);
            }
            if (HasCurrentStopSequence)
            {
                size += 1 + pb::CodedOutputStream.ComputeUInt32Size(CurrentStopSequence);
            }
            if (HasStopId)
            {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(StopId);
            }
            if (HasCurrentStatus)
            {
                size += 1 + pb::CodedOutputStream.ComputeEnumSize((int)CurrentStatus);
            }
            if (HasTimestamp)
            {
                size += 1 + pb::CodedOutputStream.ComputeUInt64Size(Timestamp);
            }
            if (HasCongestionLevel)
            {
                size += 1 + pb::CodedOutputStream.ComputeEnumSize((int)CongestionLevel);
            }
            if (HasOccupancyStatus)
            {
                size += 1 + pb::CodedOutputStream.ComputeEnumSize((int)OccupancyStatus);
            }
            if (_extensions != null)
            {
                size += _extensions.CalculateSize();
            }
            if (_unknownFields != null)
            {
                size += _unknownFields.CalculateSize();
            }
            return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(VehiclePosition other)
        {
            if (other == null)
            {
                return;
            }
            if (other.trip_ != null)
            {
                if (trip_ == null)
                {
                    Trip = new global::STM.ExternalServiceProvider.Proto.TripDescriptor();
                }
                Trip.MergeFrom(other.Trip);
            }
            if (other.vehicle_ != null)
            {
                if (vehicle_ == null)
                {
                    Vehicle = new global::STM.ExternalServiceProvider.Proto.VehicleDescriptor();
                }
                Vehicle.MergeFrom(other.Vehicle);
            }
            if (other.position_ != null)
            {
                if (position_ == null)
                {
                    Position = new global::STM.ExternalServiceProvider.Proto.Position();
                }
                Position.MergeFrom(other.Position);
            }
            if (other.HasCurrentStopSequence)
            {
                CurrentStopSequence = other.CurrentStopSequence;
            }
            if (other.HasStopId)
            {
                StopId = other.StopId;
            }
            if (other.HasCurrentStatus)
            {
                CurrentStatus = other.CurrentStatus;
            }
            if (other.HasTimestamp)
            {
                Timestamp = other.Timestamp;
            }
            if (other.HasCongestionLevel)
            {
                CongestionLevel = other.CongestionLevel;
            }
            if (other.HasOccupancyStatus)
            {
                OccupancyStatus = other.OccupancyStatus;
            }
            pb::ExtensionSet.MergeFrom(ref _extensions, other._extensions);
            _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input)
        {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            input.ReadRawMessage(this);
#else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            if (!pb::ExtensionSet.TryMergeFieldFrom(ref _extensions, input)) {
              _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            }
            break;
          case 10: {
            if (trip_ == null) {
              Ride = new global::TransitRealtime.TripDescriptor();
            }
            input.ReadMessage(Ride);
            break;
          }
          case 18: {
            if (position_ == null) {
              Position = new global::TransitRealtime.Position();
            }
            input.ReadMessage(Position);
            break;
          }
          case 24: {
            CurrentStopSequence = input.ReadUInt32();
            break;
          }
          case 32: {
            CurrentStatus = (global::TransitRealtime.VehiclePosition.Types.VehicleStopStatus) input.ReadEnum();
            break;
          }
          case 40: {
            Timestamp = input.ReadUInt64();
            break;
          }
          case 48: {
            CongestionLevel = (global::TransitRealtime.VehiclePosition.Types.CongestionLevel) input.ReadEnum();
            break;
          }
          case 58: {
            StopId = input.ReadString();
            break;
          }
          case 66: {
            if (vehicle_ == null) {
              Vehicle = new global::TransitRealtime.VehicleDescriptor();
            }
            input.ReadMessage(Vehicle);
            break;
          }
          case 72: {
            OccupancyStatus = (global::TransitRealtime.VehiclePosition.Types.OccupancyStatus) input.ReadEnum();
            break;
          }
        }
      }
#endif
        }

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input)
        {
            uint tag;
            while ((tag = input.ReadTag()) != 0)
            {
                switch (tag)
                {
                    default:
                        if (!pb::ExtensionSet.TryMergeFieldFrom(ref _extensions, ref input))
                        {
                            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                        }
                        break;
                    case 10:
                        {
                            if (trip_ == null)
                            {
                                Trip = new global::STM.ExternalServiceProvider.Proto.TripDescriptor();
                            }
                            input.ReadMessage(Trip);
                            break;
                        }
                    case 18:
                        {
                            if (position_ == null)
                            {
                                Position = new global::STM.ExternalServiceProvider.Proto.Position();
                            }
                            input.ReadMessage(Position);
                            break;
                        }
                    case 24:
                        {
                            CurrentStopSequence = input.ReadUInt32();
                            break;
                        }
                    case 32:
                        {
                            CurrentStatus = (global::STM.ExternalServiceProvider.Proto.VehiclePosition.Types.VehicleStopStatus)input.ReadEnum();
                            break;
                        }
                    case 40:
                        {
                            Timestamp = input.ReadUInt64();
                            break;
                        }
                    case 48:
                        {
                            CongestionLevel = (global::STM.ExternalServiceProvider.Proto.VehiclePosition.Types.CongestionLevel)input.ReadEnum();
                            break;
                        }
                    case 58:
                        {
                            StopId = input.ReadString();
                            break;
                        }
                    case 66:
                        {
                            if (vehicle_ == null)
                            {
                                Vehicle = new global::STM.ExternalServiceProvider.Proto.VehicleDescriptor();
                            }
                            input.ReadMessage(Vehicle);
                            break;
                        }
                    case 72:
                        {
                            OccupancyStatus = (global::STM.ExternalServiceProvider.Proto.VehiclePosition.Types.OccupancyStatus)input.ReadEnum();
                            break;
                        }
                }
            }
        }
#endif

        public TValue GetExtension<TValue>(pb::Extension<VehiclePosition, TValue> extension)
        {
            return pb::ExtensionSet.Get(ref _extensions, extension);
        }
        public pbc::RepeatedField<TValue> GetExtension<TValue>(pb::RepeatedExtension<VehiclePosition, TValue> extension)
        {
            return pb::ExtensionSet.Get(ref _extensions, extension);
        }
        public pbc::RepeatedField<TValue> GetOrInitializeExtension<TValue>(pb::RepeatedExtension<VehiclePosition, TValue> extension)
        {
            return pb::ExtensionSet.GetOrInitialize(ref _extensions, extension);
        }
        public void SetExtension<TValue>(pb::Extension<VehiclePosition, TValue> extension, TValue value)
        {
            pb::ExtensionSet.Set(ref _extensions, extension, value);
        }
        public bool HasExtension<TValue>(pb::Extension<VehiclePosition, TValue> extension)
        {
            return pb::ExtensionSet.Has(ref _extensions, extension);
        }
        public void ClearExtension<TValue>(pb::Extension<VehiclePosition, TValue> extension)
        {
            pb::ExtensionSet.Clear(ref _extensions, extension);
        }
        public void ClearExtension<TValue>(pb::RepeatedExtension<VehiclePosition, TValue> extension)
        {
            pb::ExtensionSet.Clear(ref _extensions, extension);
        }

        #region Nested types
        /// <summary>Container for nested types declared in the VehiclePosition message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static partial class Types
        {
            public enum VehicleStopStatus
            {
                /// <summary>
                /// The vehicle is just about to arrive at the stop (on a stop
                /// display, the vehicle symbol typically flashes).
                /// </summary>
                [pbr::OriginalName("INCOMING_AT")] IncomingAt = 0,
                /// <summary>
                /// The vehicle is standing at the stop.
                /// </summary>
                [pbr::OriginalName("STOPPED_AT")] StoppedAt = 1,
                /// <summary>
                /// The vehicle has departed and is in transit to the next stop.
                /// </summary>
                [pbr::OriginalName("IN_TRANSIT_TO")] InTransitTo = 2,
            }

            /// <summary>
            /// Congestion level that is affecting this vehicle.
            /// </summary>
            public enum CongestionLevel
            {
                [pbr::OriginalName("UNKNOWN_CONGESTION_LEVEL")] UnknownCongestionLevel = 0,
                [pbr::OriginalName("RUNNING_SMOOTHLY")] RunningSmoothly = 1,
                [pbr::OriginalName("STOP_AND_GO")] StopAndGo = 2,
                [pbr::OriginalName("CONGESTION")] Congestion = 3,
                /// <summary>
                /// People leaving their cars.
                /// </summary>
                [pbr::OriginalName("SEVERE_CONGESTION")] SevereCongestion = 4,
            }

            /// <summary>
            /// The degree of passenger occupancy of the vehicle. This field is still
            /// experimental, and subject to change. It may be formally adopted in the
            /// future.
            /// </summary>
            public enum OccupancyStatus
            {
                /// <summary>
                /// The vehicle is considered empty by most measures, and has few or no
                /// passengers onboard, but is still accepting passengers.
                /// </summary>
                [pbr::OriginalName("EMPTY")] Empty = 0,
                /// <summary>
                /// The vehicle has a relatively large percentage of seats available.
                /// What percentage of free seats out of the total seats available is to be
                /// considered large enough to fall into this category is determined at the
                /// discretion of the producer.
                /// </summary>
                [pbr::OriginalName("MANY_SEATS_AVAILABLE")] ManySeatsAvailable = 1,
                /// <summary>
                /// The vehicle has a relatively small percentage of seats available.
                /// What percentage of free seats out of the total seats available is to be
                /// considered small enough to fall into this category is determined at the
                /// discretion of the feed producer.
                /// </summary>
                [pbr::OriginalName("FEW_SEATS_AVAILABLE")] FewSeatsAvailable = 2,
                /// <summary>
                /// The vehicle can currently accommodate only standing passengers.
                /// </summary>
                [pbr::OriginalName("STANDING_ROOM_ONLY")] StandingRoomOnly = 3,
                /// <summary>
                /// The vehicle can currently accommodate only standing passengers
                /// and has limited space for them.
                /// </summary>
                [pbr::OriginalName("CRUSHED_STANDING_ROOM_ONLY")] CrushedStandingRoomOnly = 4,
                /// <summary>
                /// The vehicle is considered full by most measures, but may still be
                /// allowing passengers to board.
                /// </summary>
                [pbr::OriginalName("FULL")] Full = 5,
                /// <summary>
                /// The vehicle is not accepting additional passengers.
                /// </summary>
                [pbr::OriginalName("NOT_ACCEPTING_PASSENGERS")] NotAcceptingPassengers = 6,
            }

        }
        #endregion

    }

    /// <summary>
    /// An alert, indicating some sort of incident in the public transit network.
    /// </summary>
    public sealed partial class Alert : pb::IExtendableMessage<Alert>
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
#endif
    {
        private static readonly pb::MessageParser<Alert> _parser = new pb::MessageParser<Alert>(() => new Alert());
        private pb::UnknownFieldSet _unknownFields;
        private pb::ExtensionSet<Alert> _extensions;
        private pb::ExtensionSet<Alert> _Extensions { get { return _extensions; } }
        private int _hasBits0;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<Alert> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor
        {
            get { return global::STM.ExternalServiceProvider.Proto.GtfsRealtimeReflection.Descriptor.MessageTypes[5]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor
        {
            get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Alert()
        {
            OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Alert(Alert other) : this()
        {
            _hasBits0 = other._hasBits0;
            activePeriod_ = other.activePeriod_.Clone();
            informedEntity_ = other.informedEntity_.Clone();
            cause_ = other.cause_;
            effect_ = other.effect_;
            url_ = other.url_ != null ? other.url_.Clone() : null;
            headerText_ = other.headerText_ != null ? other.headerText_.Clone() : null;
            descriptionText_ = other.descriptionText_ != null ? other.descriptionText_.Clone() : null;
            _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            _extensions = pb::ExtensionSet.Clone(other._extensions);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Alert Clone()
        {
            return new Alert(this);
        }

        /// <summary>Field number for the "active_period" field.</summary>
        public const int ActivePeriodFieldNumber = 1;
        private static readonly pb::FieldCodec<global::STM.ExternalServiceProvider.Proto.TimeRange> _repeated_activePeriod_codec
            = pb::FieldCodec.ForMessage(10, global::STM.ExternalServiceProvider.Proto.TimeRange.Parser);
        private readonly pbc::RepeatedField<global::STM.ExternalServiceProvider.Proto.TimeRange> activePeriod_ = new pbc::RepeatedField<global::STM.ExternalServiceProvider.Proto.TimeRange>();
        /// <summary>
        /// Time when the alert should be shown to the user. If missing, the
        /// alert will be shown as long as it appears in the feed.
        /// If multiple ranges are given, the alert will be shown during all of them.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public pbc::RepeatedField<global::STM.ExternalServiceProvider.Proto.TimeRange> ActivePeriod
        {
            get { return activePeriod_; }
        }

        /// <summary>Field number for the "informed_entity" field.</summary>
        public const int InformedEntityFieldNumber = 5;
        private static readonly pb::FieldCodec<global::STM.ExternalServiceProvider.Proto.EntitySelector> _repeated_informedEntity_codec
            = pb::FieldCodec.ForMessage(42, global::STM.ExternalServiceProvider.Proto.EntitySelector.Parser);
        private readonly pbc::RepeatedField<global::STM.ExternalServiceProvider.Proto.EntitySelector> informedEntity_ = new pbc::RepeatedField<global::STM.ExternalServiceProvider.Proto.EntitySelector>();
        /// <summary>
        /// Entities whose users we should notify of this alert.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public pbc::RepeatedField<global::STM.ExternalServiceProvider.Proto.EntitySelector> InformedEntity
        {
            get { return informedEntity_; }
        }

        /// <summary>Field number for the "cause" field.</summary>
        public const int CauseFieldNumber = 6;
        private readonly static global::STM.ExternalServiceProvider.Proto.Alert.Types.Cause CauseDefaultValue = global::STM.ExternalServiceProvider.Proto.Alert.Types.Cause.UnknownCause;

        private global::STM.ExternalServiceProvider.Proto.Alert.Types.Cause cause_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::STM.ExternalServiceProvider.Proto.Alert.Types.Cause Cause
        {
            get { if ((_hasBits0 & 1) != 0) { return cause_; } else { return CauseDefaultValue; } }
            set
            {
                _hasBits0 |= 1;
                cause_ = value;
            }
        }
        /// <summary>Gets whether the "cause" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasCause
        {
            get { return (_hasBits0 & 1) != 0; }
        }
        /// <summary>Clears the value of the "cause" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearCause()
        {
            _hasBits0 &= ~1;
        }

        /// <summary>Field number for the "effect" field.</summary>
        public const int EffectFieldNumber = 7;
        private readonly static global::STM.ExternalServiceProvider.Proto.Alert.Types.Effect EffectDefaultValue = global::STM.ExternalServiceProvider.Proto.Alert.Types.Effect.UnknownEffect;

        private global::STM.ExternalServiceProvider.Proto.Alert.Types.Effect effect_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::STM.ExternalServiceProvider.Proto.Alert.Types.Effect Effect
        {
            get { if ((_hasBits0 & 2) != 0) { return effect_; } else { return EffectDefaultValue; } }
            set
            {
                _hasBits0 |= 2;
                effect_ = value;
            }
        }
        /// <summary>Gets whether the "effect" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasEffect
        {
            get { return (_hasBits0 & 2) != 0; }
        }
        /// <summary>Clears the value of the "effect" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearEffect()
        {
            _hasBits0 &= ~2;
        }

        /// <summary>Field number for the "url" field.</summary>
        public const int UrlFieldNumber = 8;
        private global::STM.ExternalServiceProvider.Proto.TranslatedString url_;
        /// <summary>
        /// The URL which provides additional information about the alert.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::STM.ExternalServiceProvider.Proto.TranslatedString Url
        {
            get { return url_; }
            set
            {
                url_ = value;
            }
        }

        /// <summary>Field number for the "header_text" field.</summary>
        public const int HeaderTextFieldNumber = 10;
        private global::STM.ExternalServiceProvider.Proto.TranslatedString headerText_;
        /// <summary>
        /// Alert header. Contains a short summary of the alert text as plain-text.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::STM.ExternalServiceProvider.Proto.TranslatedString HeaderText
        {
            get { return headerText_; }
            set
            {
                headerText_ = value;
            }
        }

        /// <summary>Field number for the "description_text" field.</summary>
        public const int DescriptionTextFieldNumber = 11;
        private global::STM.ExternalServiceProvider.Proto.TranslatedString descriptionText_;
        /// <summary>
        /// Full description for the alert as plain-text. The information in the
        /// description should add to the information of the header.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::STM.ExternalServiceProvider.Proto.TranslatedString DescriptionText
        {
            get { return descriptionText_; }
            set
            {
                descriptionText_ = value;
            }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other)
        {
            return Equals(other as Alert);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(Alert other)
        {
            if (ReferenceEquals(other, null))
            {
                return false;
            }
            if (ReferenceEquals(other, this))
            {
                return true;
            }
            if (!activePeriod_.Equals(other.activePeriod_)) return false;
            if (!informedEntity_.Equals(other.informedEntity_)) return false;
            if (Cause != other.Cause) return false;
            if (Effect != other.Effect) return false;
            if (!object.Equals(Url, other.Url)) return false;
            if (!object.Equals(HeaderText, other.HeaderText)) return false;
            if (!object.Equals(DescriptionText, other.DescriptionText)) return false;
            if (!Equals(_extensions, other._extensions))
            {
                return false;
            }
            return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode()
        {
            int hash = 1;
            hash ^= activePeriod_.GetHashCode();
            hash ^= informedEntity_.GetHashCode();
            if (HasCause) hash ^= Cause.GetHashCode();
            if (HasEffect) hash ^= Effect.GetHashCode();
            if (url_ != null) hash ^= Url.GetHashCode();
            if (headerText_ != null) hash ^= HeaderText.GetHashCode();
            if (descriptionText_ != null) hash ^= DescriptionText.GetHashCode();
            if (_extensions != null)
            {
                hash ^= _extensions.GetHashCode();
            }
            if (_unknownFields != null)
            {
                hash ^= _unknownFields.GetHashCode();
            }
            return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString()
        {
            return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output)
        {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            output.WriteRawMessage(this);
#else
      activePeriod_.WriteTo(output, _repeated_activePeriod_codec);
      informedEntity_.WriteTo(output, _repeated_informedEntity_codec);
      if (HasCause) {
        output.WriteRawTag(48);
        output.WriteEnum((int) Cause);
      }
      if (HasEffect) {
        output.WriteRawTag(56);
        output.WriteEnum((int) Effect);
      }
      if (url_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(Url);
      }
      if (headerText_ != null) {
        output.WriteRawTag(82);
        output.WriteMessage(HeaderText);
      }
      if (descriptionText_ != null) {
        output.WriteRawTag(90);
        output.WriteMessage(DescriptionText);
      }
      if (_extensions != null) {
        _extensions.WriteTo(output);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
#endif
        }

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output)
        {
            activePeriod_.WriteTo(ref output, _repeated_activePeriod_codec);
            informedEntity_.WriteTo(ref output, _repeated_informedEntity_codec);
            if (HasCause)
            {
                output.WriteRawTag(48);
                output.WriteEnum((int)Cause);
            }
            if (HasEffect)
            {
                output.WriteRawTag(56);
                output.WriteEnum((int)Effect);
            }
            if (url_ != null)
            {
                output.WriteRawTag(66);
                output.WriteMessage(Url);
            }
            if (headerText_ != null)
            {
                output.WriteRawTag(82);
                output.WriteMessage(HeaderText);
            }
            if (descriptionText_ != null)
            {
                output.WriteRawTag(90);
                output.WriteMessage(DescriptionText);
            }
            if (_extensions != null)
            {
                _extensions.WriteTo(ref output);
            }
            if (_unknownFields != null)
            {
                _unknownFields.WriteTo(ref output);
            }
        }
#endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize()
        {
            int size = 0;
            size += activePeriod_.CalculateSize(_repeated_activePeriod_codec);
            size += informedEntity_.CalculateSize(_repeated_informedEntity_codec);
            if (HasCause)
            {
                size += 1 + pb::CodedOutputStream.ComputeEnumSize((int)Cause);
            }
            if (HasEffect)
            {
                size += 1 + pb::CodedOutputStream.ComputeEnumSize((int)Effect);
            }
            if (url_ != null)
            {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(Url);
            }
            if (headerText_ != null)
            {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(HeaderText);
            }
            if (descriptionText_ != null)
            {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(DescriptionText);
            }
            if (_extensions != null)
            {
                size += _extensions.CalculateSize();
            }
            if (_unknownFields != null)
            {
                size += _unknownFields.CalculateSize();
            }
            return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(Alert other)
        {
            if (other == null)
            {
                return;
            }
            activePeriod_.Add(other.activePeriod_);
            informedEntity_.Add(other.informedEntity_);
            if (other.HasCause)
            {
                Cause = other.Cause;
            }
            if (other.HasEffect)
            {
                Effect = other.Effect;
            }
            if (other.url_ != null)
            {
                if (url_ == null)
                {
                    Url = new global::STM.ExternalServiceProvider.Proto.TranslatedString();
                }
                Url.MergeFrom(other.Url);
            }
            if (other.headerText_ != null)
            {
                if (headerText_ == null)
                {
                    HeaderText = new global::STM.ExternalServiceProvider.Proto.TranslatedString();
                }
                HeaderText.MergeFrom(other.HeaderText);
            }
            if (other.descriptionText_ != null)
            {
                if (descriptionText_ == null)
                {
                    DescriptionText = new global::STM.ExternalServiceProvider.Proto.TranslatedString();
                }
                DescriptionText.MergeFrom(other.DescriptionText);
            }
            pb::ExtensionSet.MergeFrom(ref _extensions, other._extensions);
            _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input)
        {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            input.ReadRawMessage(this);
#else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            if (!pb::ExtensionSet.TryMergeFieldFrom(ref _extensions, input)) {
              _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            }
            break;
          case 10: {
            activePeriod_.AddEntriesFrom(input, _repeated_activePeriod_codec);
            break;
          }
          case 42: {
            informedEntity_.AddEntriesFrom(input, _repeated_informedEntity_codec);
            break;
          }
          case 48: {
            Cause = (global::TransitRealtime.Alert.Types.Cause) input.ReadEnum();
            break;
          }
          case 56: {
            Effect = (global::TransitRealtime.Alert.Types.Effect) input.ReadEnum();
            break;
          }
          case 66: {
            if (url_ == null) {
              Url = new global::TransitRealtime.TranslatedString();
            }
            input.ReadMessage(Url);
            break;
          }
          case 82: {
            if (headerText_ == null) {
              HeaderText = new global::TransitRealtime.TranslatedString();
            }
            input.ReadMessage(HeaderText);
            break;
          }
          case 90: {
            if (descriptionText_ == null) {
              DescriptionText = new global::TransitRealtime.TranslatedString();
            }
            input.ReadMessage(DescriptionText);
            break;
          }
        }
      }
#endif
        }

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input)
        {
            uint tag;
            while ((tag = input.ReadTag()) != 0)
            {
                switch (tag)
                {
                    default:
                        if (!pb::ExtensionSet.TryMergeFieldFrom(ref _extensions, ref input))
                        {
                            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                        }
                        break;
                    case 10:
                        {
                            activePeriod_.AddEntriesFrom(ref input, _repeated_activePeriod_codec);
                            break;
                        }
                    case 42:
                        {
                            informedEntity_.AddEntriesFrom(ref input, _repeated_informedEntity_codec);
                            break;
                        }
                    case 48:
                        {
                            Cause = (global::STM.ExternalServiceProvider.Proto.Alert.Types.Cause)input.ReadEnum();
                            break;
                        }
                    case 56:
                        {
                            Effect = (global::STM.ExternalServiceProvider.Proto.Alert.Types.Effect)input.ReadEnum();
                            break;
                        }
                    case 66:
                        {
                            if (url_ == null)
                            {
                                Url = new global::STM.ExternalServiceProvider.Proto.TranslatedString();
                            }
                            input.ReadMessage(Url);
                            break;
                        }
                    case 82:
                        {
                            if (headerText_ == null)
                            {
                                HeaderText = new global::STM.ExternalServiceProvider.Proto.TranslatedString();
                            }
                            input.ReadMessage(HeaderText);
                            break;
                        }
                    case 90:
                        {
                            if (descriptionText_ == null)
                            {
                                DescriptionText = new global::STM.ExternalServiceProvider.Proto.TranslatedString();
                            }
                            input.ReadMessage(DescriptionText);
                            break;
                        }
                }
            }
        }
#endif

        public TValue GetExtension<TValue>(pb::Extension<Alert, TValue> extension)
        {
            return pb::ExtensionSet.Get(ref _extensions, extension);
        }
        public pbc::RepeatedField<TValue> GetExtension<TValue>(pb::RepeatedExtension<Alert, TValue> extension)
        {
            return pb::ExtensionSet.Get(ref _extensions, extension);
        }
        public pbc::RepeatedField<TValue> GetOrInitializeExtension<TValue>(pb::RepeatedExtension<Alert, TValue> extension)
        {
            return pb::ExtensionSet.GetOrInitialize(ref _extensions, extension);
        }
        public void SetExtension<TValue>(pb::Extension<Alert, TValue> extension, TValue value)
        {
            pb::ExtensionSet.Set(ref _extensions, extension, value);
        }
        public bool HasExtension<TValue>(pb::Extension<Alert, TValue> extension)
        {
            return pb::ExtensionSet.Has(ref _extensions, extension);
        }
        public void ClearExtension<TValue>(pb::Extension<Alert, TValue> extension)
        {
            pb::ExtensionSet.Clear(ref _extensions, extension);
        }
        public void ClearExtension<TValue>(pb::RepeatedExtension<Alert, TValue> extension)
        {
            pb::ExtensionSet.Clear(ref _extensions, extension);
        }

        #region Nested types
        /// <summary>Container for nested types declared in the Alert message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static partial class Types
        {
            /// <summary>
            /// Cause of this alert.
            /// </summary>
            public enum Cause
            {
                [pbr::OriginalName("UNKNOWN_CAUSE")] UnknownCause = 1,
                /// <summary>
                /// Not machine-representable.
                /// </summary>
                [pbr::OriginalName("OTHER_CAUSE")] OtherCause = 2,
                [pbr::OriginalName("TECHNICAL_PROBLEM")] TechnicalProblem = 3,
                /// <summary>
                /// Public transit agency employees stopped working.
                /// </summary>
                [pbr::OriginalName("STRIKE")] Strike = 4,
                /// <summary>
                /// People are blocking the streets.
                /// </summary>
                [pbr::OriginalName("DEMONSTRATION")] Demonstration = 5,
                [pbr::OriginalName("ACCIDENT")] Accident = 6,
                [pbr::OriginalName("HOLIDAY")] Holiday = 7,
                [pbr::OriginalName("WEATHER")] Weather = 8,
                [pbr::OriginalName("MAINTENANCE")] Maintenance = 9,
                [pbr::OriginalName("CONSTRUCTION")] Construction = 10,
                [pbr::OriginalName("POLICE_ACTIVITY")] PoliceActivity = 11,
                [pbr::OriginalName("MEDICAL_EMERGENCY")] MedicalEmergency = 12,
            }

            /// <summary>
            /// What is the effect of this problem on the affected entity.
            /// </summary>
            public enum Effect
            {
                [pbr::OriginalName("NO_SERVICE")] NoService = 1,
                [pbr::OriginalName("REDUCED_SERVICE")] ReducedService = 2,
                /// <summary>
                /// We don't care about INsignificant delays: they are hard to detect, have
                /// little impact on the user, and would clutter the results as they are too
                /// frequent.
                /// </summary>
                [pbr::OriginalName("SIGNIFICANT_DELAYS")] SignificantDelays = 3,
                [pbr::OriginalName("DETOUR")] Detour = 4,
                [pbr::OriginalName("ADDITIONAL_SERVICE")] AdditionalService = 5,
                [pbr::OriginalName("MODIFIED_SERVICE")] ModifiedService = 6,
                [pbr::OriginalName("OTHER_EFFECT")] OtherEffect = 7,
                [pbr::OriginalName("UNKNOWN_EFFECT")] UnknownEffect = 8,
                [pbr::OriginalName("STOP_MOVED")] StopMoved = 9,
            }

        }
        #endregion

    }

    /// <summary>
    /// A time interval. The interval is considered active at time 't' if 't' is
    /// greater than or equal to the start time and less than the end time.
    /// </summary>
    public sealed partial class TimeRange : pb::IExtendableMessage<TimeRange>
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
#endif
    {
        private static readonly pb::MessageParser<TimeRange> _parser = new pb::MessageParser<TimeRange>(() => new TimeRange());
        private pb::UnknownFieldSet _unknownFields;
        private pb::ExtensionSet<TimeRange> _extensions;
        private pb::ExtensionSet<TimeRange> _Extensions { get { return _extensions; } }
        private int _hasBits0;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<TimeRange> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor
        {
            get { return global::STM.ExternalServiceProvider.Proto.GtfsRealtimeReflection.Descriptor.MessageTypes[6]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor
        {
            get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public TimeRange()
        {
            OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public TimeRange(TimeRange other) : this()
        {
            _hasBits0 = other._hasBits0;
            start_ = other.start_;
            end_ = other.end_;
            _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            _extensions = pb::ExtensionSet.Clone(other._extensions);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public TimeRange Clone()
        {
            return new TimeRange(this);
        }

        /// <summary>Field number for the "start" field.</summary>
        public const int StartFieldNumber = 1;
        private readonly static ulong StartDefaultValue = 0UL;

        private ulong start_;
        /// <summary>
        /// Start time, in POSIX time (i.e., number of seconds since January 1st 1970
        /// 00:00:00 UTC).
        /// If missing, the interval starts at minus infinity.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public ulong Start
        {
            get { if ((_hasBits0 & 1) != 0) { return start_; } else { return StartDefaultValue; } }
            set
            {
                _hasBits0 |= 1;
                start_ = value;
            }
        }
        /// <summary>Gets whether the "start" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasStart
        {
            get { return (_hasBits0 & 1) != 0; }
        }
        /// <summary>Clears the value of the "start" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearStart()
        {
            _hasBits0 &= ~1;
        }

        /// <summary>Field number for the "end" field.</summary>
        public const int EndFieldNumber = 2;
        private readonly static ulong EndDefaultValue = 0UL;

        private ulong end_;
        /// <summary>
        /// End time, in POSIX time (i.e., number of seconds since January 1st 1970
        /// 00:00:00 UTC).
        /// If missing, the interval ends at plus infinity.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public ulong End
        {
            get { if ((_hasBits0 & 2) != 0) { return end_; } else { return EndDefaultValue; } }
            set
            {
                _hasBits0 |= 2;
                end_ = value;
            }
        }
        /// <summary>Gets whether the "end" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasEnd
        {
            get { return (_hasBits0 & 2) != 0; }
        }
        /// <summary>Clears the value of the "end" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearEnd()
        {
            _hasBits0 &= ~2;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other)
        {
            return Equals(other as TimeRange);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(TimeRange other)
        {
            if (ReferenceEquals(other, null))
            {
                return false;
            }
            if (ReferenceEquals(other, this))
            {
                return true;
            }
            if (Start != other.Start) return false;
            if (End != other.End) return false;
            if (!Equals(_extensions, other._extensions))
            {
                return false;
            }
            return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode()
        {
            int hash = 1;
            if (HasStart) hash ^= Start.GetHashCode();
            if (HasEnd) hash ^= End.GetHashCode();
            if (_extensions != null)
            {
                hash ^= _extensions.GetHashCode();
            }
            if (_unknownFields != null)
            {
                hash ^= _unknownFields.GetHashCode();
            }
            return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString()
        {
            return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output)
        {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            output.WriteRawMessage(this);
#else
      if (HasStart) {
        output.WriteRawTag(8);
        output.WriteUInt64(Start);
      }
      if (HasEnd) {
        output.WriteRawTag(16);
        output.WriteUInt64(End);
      }
      if (_extensions != null) {
        _extensions.WriteTo(output);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
#endif
        }

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output)
        {
            if (HasStart)
            {
                output.WriteRawTag(8);
                output.WriteUInt64(Start);
            }
            if (HasEnd)
            {
                output.WriteRawTag(16);
                output.WriteUInt64(End);
            }
            if (_extensions != null)
            {
                _extensions.WriteTo(ref output);
            }
            if (_unknownFields != null)
            {
                _unknownFields.WriteTo(ref output);
            }
        }
#endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize()
        {
            int size = 0;
            if (HasStart)
            {
                size += 1 + pb::CodedOutputStream.ComputeUInt64Size(Start);
            }
            if (HasEnd)
            {
                size += 1 + pb::CodedOutputStream.ComputeUInt64Size(End);
            }
            if (_extensions != null)
            {
                size += _extensions.CalculateSize();
            }
            if (_unknownFields != null)
            {
                size += _unknownFields.CalculateSize();
            }
            return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(TimeRange other)
        {
            if (other == null)
            {
                return;
            }
            if (other.HasStart)
            {
                Start = other.Start;
            }
            if (other.HasEnd)
            {
                End = other.End;
            }
            pb::ExtensionSet.MergeFrom(ref _extensions, other._extensions);
            _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input)
        {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            input.ReadRawMessage(this);
#else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            if (!pb::ExtensionSet.TryMergeFieldFrom(ref _extensions, input)) {
              _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            }
            break;
          case 8: {
            Start = input.ReadUInt64();
            break;
          }
          case 16: {
            End = input.ReadUInt64();
            break;
          }
        }
      }
#endif
        }

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input)
        {
            uint tag;
            while ((tag = input.ReadTag()) != 0)
            {
                switch (tag)
                {
                    default:
                        if (!pb::ExtensionSet.TryMergeFieldFrom(ref _extensions, ref input))
                        {
                            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                        }
                        break;
                    case 8:
                        {
                            Start = input.ReadUInt64();
                            break;
                        }
                    case 16:
                        {
                            End = input.ReadUInt64();
                            break;
                        }
                }
            }
        }
#endif

        public TValue GetExtension<TValue>(pb::Extension<TimeRange, TValue> extension)
        {
            return pb::ExtensionSet.Get(ref _extensions, extension);
        }
        public pbc::RepeatedField<TValue> GetExtension<TValue>(pb::RepeatedExtension<TimeRange, TValue> extension)
        {
            return pb::ExtensionSet.Get(ref _extensions, extension);
        }
        public pbc::RepeatedField<TValue> GetOrInitializeExtension<TValue>(pb::RepeatedExtension<TimeRange, TValue> extension)
        {
            return pb::ExtensionSet.GetOrInitialize(ref _extensions, extension);
        }
        public void SetExtension<TValue>(pb::Extension<TimeRange, TValue> extension, TValue value)
        {
            pb::ExtensionSet.Set(ref _extensions, extension, value);
        }
        public bool HasExtension<TValue>(pb::Extension<TimeRange, TValue> extension)
        {
            return pb::ExtensionSet.Has(ref _extensions, extension);
        }
        public void ClearExtension<TValue>(pb::Extension<TimeRange, TValue> extension)
        {
            pb::ExtensionSet.Clear(ref _extensions, extension);
        }
        public void ClearExtension<TValue>(pb::RepeatedExtension<TimeRange, TValue> extension)
        {
            pb::ExtensionSet.Clear(ref _extensions, extension);
        }

    }

    /// <summary>
    /// A position.
    /// </summary>
    public sealed partial class Position : pb::IExtendableMessage<Position>
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
#endif
    {
        private static readonly pb::MessageParser<Position> _parser = new pb::MessageParser<Position>(() => new Position());
        private pb::UnknownFieldSet _unknownFields;
        private pb::ExtensionSet<Position> _extensions;
        private pb::ExtensionSet<Position> _Extensions { get { return _extensions; } }
        private int _hasBits0;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<Position> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor
        {
            get { return global::STM.ExternalServiceProvider.Proto.GtfsRealtimeReflection.Descriptor.MessageTypes[7]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor
        {
            get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Position()
        {
            OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Position(Position other) : this()
        {
            _hasBits0 = other._hasBits0;
            latitude_ = other.latitude_;
            longitude_ = other.longitude_;
            bearing_ = other.bearing_;
            odometer_ = other.odometer_;
            speed_ = other.speed_;
            _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            _extensions = pb::ExtensionSet.Clone(other._extensions);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Position Clone()
        {
            return new Position(this);
        }

        /// <summary>Field number for the "latitude" field.</summary>
        public const int LatitudeFieldNumber = 1;
        private readonly static float LatitudeDefaultValue = 0F;

        private float latitude_;
        /// <summary>
        /// Degrees North, in the WGS-84 coordinate system.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public float Latitude
        {
            get { if ((_hasBits0 & 1) != 0) { return latitude_; } else { return LatitudeDefaultValue; } }
            set
            {
                _hasBits0 |= 1;
                latitude_ = value;
            }
        }
        /// <summary>Gets whether the "latitude" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasLatitude
        {
            get { return (_hasBits0 & 1) != 0; }
        }
        /// <summary>Clears the value of the "latitude" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearLatitude()
        {
            _hasBits0 &= ~1;
        }

        /// <summary>Field number for the "longitude" field.</summary>
        public const int LongitudeFieldNumber = 2;
        private readonly static float LongitudeDefaultValue = 0F;

        private float longitude_;
        /// <summary>
        /// Degrees East, in the WGS-84 coordinate system.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public float Longitude
        {
            get { if ((_hasBits0 & 2) != 0) { return longitude_; } else { return LongitudeDefaultValue; } }
            set
            {
                _hasBits0 |= 2;
                longitude_ = value;
            }
        }
        /// <summary>Gets whether the "longitude" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasLongitude
        {
            get { return (_hasBits0 & 2) != 0; }
        }
        /// <summary>Clears the value of the "longitude" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearLongitude()
        {
            _hasBits0 &= ~2;
        }

        /// <summary>Field number for the "bearing" field.</summary>
        public const int BearingFieldNumber = 3;
        private readonly static float BearingDefaultValue = 0F;

        private float bearing_;
        /// <summary>
        /// Bearing, in degrees, clockwise from North, i.e., 0 is North and 90 is East.
        /// This can be the compass bearing, or the direction towards the next stop
        /// or intermediate location.
        /// This should not be direction deduced from the sequence of previous
        /// positions, which can be computed from previous data.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public float Bearing
        {
            get { if ((_hasBits0 & 4) != 0) { return bearing_; } else { return BearingDefaultValue; } }
            set
            {
                _hasBits0 |= 4;
                bearing_ = value;
            }
        }
        /// <summary>Gets whether the "bearing" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasBearing
        {
            get { return (_hasBits0 & 4) != 0; }
        }
        /// <summary>Clears the value of the "bearing" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearBearing()
        {
            _hasBits0 &= ~4;
        }

        /// <summary>Field number for the "odometer" field.</summary>
        public const int OdometerFieldNumber = 4;
        private readonly static double OdometerDefaultValue = 0D;

        private double odometer_;
        /// <summary>
        /// Odometer value, in meters.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public double Odometer
        {
            get { if ((_hasBits0 & 8) != 0) { return odometer_; } else { return OdometerDefaultValue; } }
            set
            {
                _hasBits0 |= 8;
                odometer_ = value;
            }
        }
        /// <summary>Gets whether the "odometer" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasOdometer
        {
            get { return (_hasBits0 & 8) != 0; }
        }
        /// <summary>Clears the value of the "odometer" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearOdometer()
        {
            _hasBits0 &= ~8;
        }

        /// <summary>Field number for the "speed" field.</summary>
        public const int SpeedFieldNumber = 5;
        private readonly static float SpeedDefaultValue = 0F;

        private float speed_;
        /// <summary>
        /// Momentary speed measured by the vehicle, in meters per second.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public float Speed
        {
            get { if ((_hasBits0 & 16) != 0) { return speed_; } else { return SpeedDefaultValue; } }
            set
            {
                _hasBits0 |= 16;
                speed_ = value;
            }
        }
        /// <summary>Gets whether the "speed" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasSpeed
        {
            get { return (_hasBits0 & 16) != 0; }
        }
        /// <summary>Clears the value of the "speed" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearSpeed()
        {
            _hasBits0 &= ~16;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other)
        {
            return Equals(other as Position);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(Position other)
        {
            if (ReferenceEquals(other, null))
            {
                return false;
            }
            if (ReferenceEquals(other, this))
            {
                return true;
            }
            if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(Latitude, other.Latitude)) return false;
            if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(Longitude, other.Longitude)) return false;
            if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(Bearing, other.Bearing)) return false;
            if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(Odometer, other.Odometer)) return false;
            if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(Speed, other.Speed)) return false;
            if (!Equals(_extensions, other._extensions))
            {
                return false;
            }
            return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode()
        {
            int hash = 1;
            if (HasLatitude) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(Latitude);
            if (HasLongitude) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(Longitude);
            if (HasBearing) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(Bearing);
            if (HasOdometer) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(Odometer);
            if (HasSpeed) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(Speed);
            if (_extensions != null)
            {
                hash ^= _extensions.GetHashCode();
            }
            if (_unknownFields != null)
            {
                hash ^= _unknownFields.GetHashCode();
            }
            return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString()
        {
            return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output)
        {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            output.WriteRawMessage(this);
#else
      if (HasLatitude) {
        output.WriteRawTag(13);
        output.WriteFloat(Latitude);
      }
      if (HasLongitude) {
        output.WriteRawTag(21);
        output.WriteFloat(Longitude);
      }
      if (HasBearing) {
        output.WriteRawTag(29);
        output.WriteFloat(Bearing);
      }
      if (HasOdometer) {
        output.WriteRawTag(33);
        output.WriteDouble(Odometer);
      }
      if (HasSpeed) {
        output.WriteRawTag(45);
        output.WriteFloat(Speed);
      }
      if (_extensions != null) {
        _extensions.WriteTo(output);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
#endif
        }

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output)
        {
            if (HasLatitude)
            {
                output.WriteRawTag(13);
                output.WriteFloat(Latitude);
            }
            if (HasLongitude)
            {
                output.WriteRawTag(21);
                output.WriteFloat(Longitude);
            }
            if (HasBearing)
            {
                output.WriteRawTag(29);
                output.WriteFloat(Bearing);
            }
            if (HasOdometer)
            {
                output.WriteRawTag(33);
                output.WriteDouble(Odometer);
            }
            if (HasSpeed)
            {
                output.WriteRawTag(45);
                output.WriteFloat(Speed);
            }
            if (_extensions != null)
            {
                _extensions.WriteTo(ref output);
            }
            if (_unknownFields != null)
            {
                _unknownFields.WriteTo(ref output);
            }
        }
#endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize()
        {
            int size = 0;
            if (HasLatitude)
            {
                size += 1 + 4;
            }
            if (HasLongitude)
            {
                size += 1 + 4;
            }
            if (HasBearing)
            {
                size += 1 + 4;
            }
            if (HasOdometer)
            {
                size += 1 + 8;
            }
            if (HasSpeed)
            {
                size += 1 + 4;
            }
            if (_extensions != null)
            {
                size += _extensions.CalculateSize();
            }
            if (_unknownFields != null)
            {
                size += _unknownFields.CalculateSize();
            }
            return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(Position other)
        {
            if (other == null)
            {
                return;
            }
            if (other.HasLatitude)
            {
                Latitude = other.Latitude;
            }
            if (other.HasLongitude)
            {
                Longitude = other.Longitude;
            }
            if (other.HasBearing)
            {
                Bearing = other.Bearing;
            }
            if (other.HasOdometer)
            {
                Odometer = other.Odometer;
            }
            if (other.HasSpeed)
            {
                Speed = other.Speed;
            }
            pb::ExtensionSet.MergeFrom(ref _extensions, other._extensions);
            _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input)
        {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            input.ReadRawMessage(this);
#else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            if (!pb::ExtensionSet.TryMergeFieldFrom(ref _extensions, input)) {
              _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            }
            break;
          case 13: {
            Latitude = input.ReadFloat();
            break;
          }
          case 21: {
            Longitude = input.ReadFloat();
            break;
          }
          case 29: {
            Bearing = input.ReadFloat();
            break;
          }
          case 33: {
            Odometer = input.ReadDouble();
            break;
          }
          case 45: {
            Speed = input.ReadFloat();
            break;
          }
        }
      }
#endif
        }

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input)
        {
            uint tag;
            while ((tag = input.ReadTag()) != 0)
            {
                switch (tag)
                {
                    default:
                        if (!pb::ExtensionSet.TryMergeFieldFrom(ref _extensions, ref input))
                        {
                            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                        }
                        break;
                    case 13:
                        {
                            Latitude = input.ReadFloat();
                            break;
                        }
                    case 21:
                        {
                            Longitude = input.ReadFloat();
                            break;
                        }
                    case 29:
                        {
                            Bearing = input.ReadFloat();
                            break;
                        }
                    case 33:
                        {
                            Odometer = input.ReadDouble();
                            break;
                        }
                    case 45:
                        {
                            Speed = input.ReadFloat();
                            break;
                        }
                }
            }
        }
#endif

        public TValue GetExtension<TValue>(pb::Extension<Position, TValue> extension)
        {
            return pb::ExtensionSet.Get(ref _extensions, extension);
        }
        public pbc::RepeatedField<TValue> GetExtension<TValue>(pb::RepeatedExtension<Position, TValue> extension)
        {
            return pb::ExtensionSet.Get(ref _extensions, extension);
        }
        public pbc::RepeatedField<TValue> GetOrInitializeExtension<TValue>(pb::RepeatedExtension<Position, TValue> extension)
        {
            return pb::ExtensionSet.GetOrInitialize(ref _extensions, extension);
        }
        public void SetExtension<TValue>(pb::Extension<Position, TValue> extension, TValue value)
        {
            pb::ExtensionSet.Set(ref _extensions, extension, value);
        }
        public bool HasExtension<TValue>(pb::Extension<Position, TValue> extension)
        {
            return pb::ExtensionSet.Has(ref _extensions, extension);
        }
        public void ClearExtension<TValue>(pb::Extension<Position, TValue> extension)
        {
            pb::ExtensionSet.Clear(ref _extensions, extension);
        }
        public void ClearExtension<TValue>(pb::RepeatedExtension<Position, TValue> extension)
        {
            pb::ExtensionSet.Clear(ref _extensions, extension);
        }

    }

    /// <summary>
    /// A descriptor that identifies an instance of a GTFS trip, or all instances of
    /// a trip along a route.
    /// - To specify a single trip instance, the trip_id (and if necessary,
    ///   start_time) is set. If route_id is also set, then it should be same as one
    ///   that the given trip corresponds to.
    /// - To specify all the trips along a given route, only the route_id should be
    ///   set. Note that if the trip_id is not known, then stop sequence ids in
    ///   TripUpdate are not sufficient, and stop_ids must be provided as well. In
    ///   addition, absolute arrival/departure times must be provided.
    /// </summary>
    public sealed partial class TripDescriptor : pb::IExtendableMessage<TripDescriptor>
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
#endif
    {
        private static readonly pb::MessageParser<TripDescriptor> _parser = new pb::MessageParser<TripDescriptor>(() => new TripDescriptor());
        private pb::UnknownFieldSet _unknownFields;
        private pb::ExtensionSet<TripDescriptor> _extensions;
        private pb::ExtensionSet<TripDescriptor> _Extensions { get { return _extensions; } }
        private int _hasBits0;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<TripDescriptor> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor
        {
            get { return global::STM.ExternalServiceProvider.Proto.GtfsRealtimeReflection.Descriptor.MessageTypes[8]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor
        {
            get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public TripDescriptor()
        {
            OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public TripDescriptor(TripDescriptor other) : this()
        {
            _hasBits0 = other._hasBits0;
            tripId_ = other.tripId_;
            routeId_ = other.routeId_;
            directionId_ = other.directionId_;
            startTime_ = other.startTime_;
            startDate_ = other.startDate_;
            scheduleRelationship_ = other.scheduleRelationship_;
            _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            _extensions = pb::ExtensionSet.Clone(other._extensions);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public TripDescriptor Clone()
        {
            return new TripDescriptor(this);
        }

        /// <summary>Field number for the "trip_id" field.</summary>
        public const int TripIdFieldNumber = 1;
        private readonly static string TripIdDefaultValue = "";

        private string tripId_;
        /// <summary>
        /// The trip_id from the GTFS feed that this selector refers to.
        /// For non frequency-based trips, this field is enough to uniquely identify
        /// the trip. For frequency-based trip, start_time and start_date might also be
        /// necessary.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public string TripId
        {
            get { return tripId_ ?? TripIdDefaultValue; }
            set
            {
                tripId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
            }
        }
        /// <summary>Gets whether the "trip_id" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasTripId
        {
            get { return tripId_ != null; }
        }
        /// <summary>Clears the value of the "trip_id" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearTripId()
        {
            tripId_ = null;
        }

        /// <summary>Field number for the "route_id" field.</summary>
        public const int RouteIdFieldNumber = 5;
        private readonly static string RouteIdDefaultValue = "";

        private string routeId_;
        /// <summary>
        /// The route_id from the GTFS that this selector refers to.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public string RouteId
        {
            get { return routeId_ ?? RouteIdDefaultValue; }
            set
            {
                routeId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
            }
        }
        /// <summary>Gets whether the "route_id" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasRouteId
        {
            get { return routeId_ != null; }
        }
        /// <summary>Clears the value of the "route_id" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearRouteId()
        {
            routeId_ = null;
        }

        /// <summary>Field number for the "direction_id" field.</summary>
        public const int DirectionIdFieldNumber = 6;
        private readonly static uint DirectionIdDefaultValue = 0;

        private uint directionId_;
        /// <summary>
        /// The direction_id from the GTFS feed trips.txt file, indicating the
        /// direction of travel for trips this selector refers to. This field is
        /// still experimental, and subject to change. It may be formally adopted in
        /// the future.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public uint DirectionId
        {
            get { if ((_hasBits0 & 2) != 0) { return directionId_; } else { return DirectionIdDefaultValue; } }
            set
            {
                _hasBits0 |= 2;
                directionId_ = value;
            }
        }
        /// <summary>Gets whether the "direction_id" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasDirectionId
        {
            get { return (_hasBits0 & 2) != 0; }
        }
        /// <summary>Clears the value of the "direction_id" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearDirectionId()
        {
            _hasBits0 &= ~2;
        }

        /// <summary>Field number for the "start_time" field.</summary>
        public const int StartTimeFieldNumber = 2;
        private readonly static string StartTimeDefaultValue = "";

        private string startTime_;
        /// <summary>
        /// The initially scheduled start time of this trip instance.
        /// When the trip_id corresponds to a non-frequency-based trip, this field
        /// should either be omitted or be equal to the value in the GTFS feed. When
        /// the trip_id corresponds to a frequency-based trip, the start_time must be
        /// specified for trip updates and vehicle positions. If the trip corresponds
        /// to exact_times=1 GTFS record, then start_time must be some multiple
        /// (including zero) of headway_secs later than frequencies.txt start_time for
        /// the corresponding time period. If the trip corresponds to exact_times=0,
        /// then its start_time may be arbitrary, and is initially expected to be the
        /// first departure of the trip. Once established, the start_time of this
        /// frequency-based trip should be considered immutable, even if the first
        /// departure time changes -- that time change may instead be reflected in a
        /// StopTimeUpdate.
        /// Format and semantics of the field is same as that of
        /// GTFS/frequencies.txt/start_time, e.g., 11:15:35 or 25:15:35.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public string StartTime
        {
            get { return startTime_ ?? StartTimeDefaultValue; }
            set
            {
                startTime_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
            }
        }
        /// <summary>Gets whether the "start_time" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasStartTime
        {
            get { return startTime_ != null; }
        }
        /// <summary>Clears the value of the "start_time" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearStartTime()
        {
            startTime_ = null;
        }

        /// <summary>Field number for the "start_date" field.</summary>
        public const int StartDateFieldNumber = 3;
        private readonly static string StartDateDefaultValue = "";

        private string startDate_;
        /// <summary>
        /// The scheduled start date of this trip instance.
        /// Must be provided to disambiguate trips that are so late as to collide with
        /// a scheduled trip on a next day. For example, for a train that departs 8:00
        /// and 20:00 every day, and is 12 hours late, there would be two distinct
        /// trips on the same time.
        /// This field can be provided but is not mandatory for schedules in which such
        /// collisions are impossible - for example, a service running on hourly
        /// schedule where a vehicle that is one hour late is not considered to be
        /// related to schedule anymore.
        /// In YYYYMMDD format.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public string StartDate
        {
            get { return startDate_ ?? StartDateDefaultValue; }
            set
            {
                startDate_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
            }
        }
        /// <summary>Gets whether the "start_date" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasStartDate
        {
            get { return startDate_ != null; }
        }
        /// <summary>Clears the value of the "start_date" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearStartDate()
        {
            startDate_ = null;
        }

        /// <summary>Field number for the "schedule_relationship" field.</summary>
        public const int ScheduleRelationshipFieldNumber = 4;
        private readonly static global::STM.ExternalServiceProvider.Proto.TripDescriptor.Types.ScheduleRelationship ScheduleRelationshipDefaultValue = global::STM.ExternalServiceProvider.Proto.TripDescriptor.Types.ScheduleRelationship.Scheduled;

        private global::STM.ExternalServiceProvider.Proto.TripDescriptor.Types.ScheduleRelationship scheduleRelationship_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::STM.ExternalServiceProvider.Proto.TripDescriptor.Types.ScheduleRelationship ScheduleRelationship
        {
            get { if ((_hasBits0 & 1) != 0) { return scheduleRelationship_; } else { return ScheduleRelationshipDefaultValue; } }
            set
            {
                _hasBits0 |= 1;
                scheduleRelationship_ = value;
            }
        }
        /// <summary>Gets whether the "schedule_relationship" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasScheduleRelationship
        {
            get { return (_hasBits0 & 1) != 0; }
        }
        /// <summary>Clears the value of the "schedule_relationship" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearScheduleRelationship()
        {
            _hasBits0 &= ~1;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other)
        {
            return Equals(other as TripDescriptor);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(TripDescriptor other)
        {
            if (ReferenceEquals(other, null))
            {
                return false;
            }
            if (ReferenceEquals(other, this))
            {
                return true;
            }
            if (TripId != other.TripId) return false;
            if (RouteId != other.RouteId) return false;
            if (DirectionId != other.DirectionId) return false;
            if (StartTime != other.StartTime) return false;
            if (StartDate != other.StartDate) return false;
            if (ScheduleRelationship != other.ScheduleRelationship) return false;
            if (!Equals(_extensions, other._extensions))
            {
                return false;
            }
            return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode()
        {
            int hash = 1;
            if (HasTripId) hash ^= TripId.GetHashCode();
            if (HasRouteId) hash ^= RouteId.GetHashCode();
            if (HasDirectionId) hash ^= DirectionId.GetHashCode();
            if (HasStartTime) hash ^= StartTime.GetHashCode();
            if (HasStartDate) hash ^= StartDate.GetHashCode();
            if (HasScheduleRelationship) hash ^= ScheduleRelationship.GetHashCode();
            if (_extensions != null)
            {
                hash ^= _extensions.GetHashCode();
            }
            if (_unknownFields != null)
            {
                hash ^= _unknownFields.GetHashCode();
            }
            return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString()
        {
            return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output)
        {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            output.WriteRawMessage(this);
#else
      if (HasTripId) {
        output.WriteRawTag(10);
        output.WriteString(TripId);
      }
      if (HasStartTime) {
        output.WriteRawTag(18);
        output.WriteString(StartTime);
      }
      if (HasStartDate) {
        output.WriteRawTag(26);
        output.WriteString(StartDate);
      }
      if (HasScheduleRelationship) {
        output.WriteRawTag(32);
        output.WriteEnum((int) ScheduleRelationship);
      }
      if (HasRouteId) {
        output.WriteRawTag(42);
        output.WriteString(RouteId);
      }
      if (HasDirectionId) {
        output.WriteRawTag(48);
        output.WriteUInt32(DirectionId);
      }
      if (_extensions != null) {
        _extensions.WriteTo(output);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
#endif
        }

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output)
        {
            if (HasTripId)
            {
                output.WriteRawTag(10);
                output.WriteString(TripId);
            }
            if (HasStartTime)
            {
                output.WriteRawTag(18);
                output.WriteString(StartTime);
            }
            if (HasStartDate)
            {
                output.WriteRawTag(26);
                output.WriteString(StartDate);
            }
            if (HasScheduleRelationship)
            {
                output.WriteRawTag(32);
                output.WriteEnum((int)ScheduleRelationship);
            }
            if (HasRouteId)
            {
                output.WriteRawTag(42);
                output.WriteString(RouteId);
            }
            if (HasDirectionId)
            {
                output.WriteRawTag(48);
                output.WriteUInt32(DirectionId);
            }
            if (_extensions != null)
            {
                _extensions.WriteTo(ref output);
            }
            if (_unknownFields != null)
            {
                _unknownFields.WriteTo(ref output);
            }
        }
#endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize()
        {
            int size = 0;
            if (HasTripId)
            {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(TripId);
            }
            if (HasRouteId)
            {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(RouteId);
            }
            if (HasDirectionId)
            {
                size += 1 + pb::CodedOutputStream.ComputeUInt32Size(DirectionId);
            }
            if (HasStartTime)
            {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(StartTime);
            }
            if (HasStartDate)
            {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(StartDate);
            }
            if (HasScheduleRelationship)
            {
                size += 1 + pb::CodedOutputStream.ComputeEnumSize((int)ScheduleRelationship);
            }
            if (_extensions != null)
            {
                size += _extensions.CalculateSize();
            }
            if (_unknownFields != null)
            {
                size += _unknownFields.CalculateSize();
            }
            return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(TripDescriptor other)
        {
            if (other == null)
            {
                return;
            }
            if (other.HasTripId)
            {
                TripId = other.TripId;
            }
            if (other.HasRouteId)
            {
                RouteId = other.RouteId;
            }
            if (other.HasDirectionId)
            {
                DirectionId = other.DirectionId;
            }
            if (other.HasStartTime)
            {
                StartTime = other.StartTime;
            }
            if (other.HasStartDate)
            {
                StartDate = other.StartDate;
            }
            if (other.HasScheduleRelationship)
            {
                ScheduleRelationship = other.ScheduleRelationship;
            }
            pb::ExtensionSet.MergeFrom(ref _extensions, other._extensions);
            _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input)
        {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            input.ReadRawMessage(this);
#else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            if (!pb::ExtensionSet.TryMergeFieldFrom(ref _extensions, input)) {
              _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            }
            break;
          case 10: {
            TripId = input.ReadString();
            break;
          }
          case 18: {
            StartTime = input.ReadString();
            break;
          }
          case 26: {
            StartDate = input.ReadString();
            break;
          }
          case 32: {
            ScheduleRelationship = (global::TransitRealtime.TripDescriptor.Types.ScheduleRelationship) input.ReadEnum();
            break;
          }
          case 42: {
            RouteId = input.ReadString();
            break;
          }
          case 48: {
            DirectionId = input.ReadUInt32();
            break;
          }
        }
      }
#endif
        }

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input)
        {
            uint tag;
            while ((tag = input.ReadTag()) != 0)
            {
                switch (tag)
                {
                    default:
                        if (!pb::ExtensionSet.TryMergeFieldFrom(ref _extensions, ref input))
                        {
                            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                        }
                        break;
                    case 10:
                        {
                            TripId = input.ReadString();
                            break;
                        }
                    case 18:
                        {
                            StartTime = input.ReadString();
                            break;
                        }
                    case 26:
                        {
                            StartDate = input.ReadString();
                            break;
                        }
                    case 32:
                        {
                            ScheduleRelationship = (global::STM.ExternalServiceProvider.Proto.TripDescriptor.Types.ScheduleRelationship)input.ReadEnum();
                            break;
                        }
                    case 42:
                        {
                            RouteId = input.ReadString();
                            break;
                        }
                    case 48:
                        {
                            DirectionId = input.ReadUInt32();
                            break;
                        }
                }
            }
        }
#endif

        public TValue GetExtension<TValue>(pb::Extension<TripDescriptor, TValue> extension)
        {
            return pb::ExtensionSet.Get(ref _extensions, extension);
        }
        public pbc::RepeatedField<TValue> GetExtension<TValue>(pb::RepeatedExtension<TripDescriptor, TValue> extension)
        {
            return pb::ExtensionSet.Get(ref _extensions, extension);
        }
        public pbc::RepeatedField<TValue> GetOrInitializeExtension<TValue>(pb::RepeatedExtension<TripDescriptor, TValue> extension)
        {
            return pb::ExtensionSet.GetOrInitialize(ref _extensions, extension);
        }
        public void SetExtension<TValue>(pb::Extension<TripDescriptor, TValue> extension, TValue value)
        {
            pb::ExtensionSet.Set(ref _extensions, extension, value);
        }
        public bool HasExtension<TValue>(pb::Extension<TripDescriptor, TValue> extension)
        {
            return pb::ExtensionSet.Has(ref _extensions, extension);
        }
        public void ClearExtension<TValue>(pb::Extension<TripDescriptor, TValue> extension)
        {
            pb::ExtensionSet.Clear(ref _extensions, extension);
        }
        public void ClearExtension<TValue>(pb::RepeatedExtension<TripDescriptor, TValue> extension)
        {
            pb::ExtensionSet.Clear(ref _extensions, extension);
        }

        #region Nested types
        /// <summary>Container for nested types declared in the TripDescriptor message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static partial class Types
        {
            /// <summary>
            /// The relation between this trip and the static schedule. If a trip is done
            /// in accordance with temporary schedule, not reflected in GTFS, then it
            /// shouldn't be marked as SCHEDULED, but likely as ADDED.
            /// </summary>
            public enum ScheduleRelationship
            {
                /// <summary>
                /// Ride that is running in accordance with its GTFS schedule, or is close
                /// enough to the scheduled trip to be associated with it.
                /// </summary>
                [pbr::OriginalName("SCHEDULED")] Scheduled = 0,
                /// <summary>
                /// An extra trip that was added in addition to a running schedule, for
                /// example, to replace a broken vehicle or to respond to sudden passenger
                /// load.
                /// </summary>
                [pbr::OriginalName("ADDED")] Added = 1,
                /// <summary>
                /// A trip that is running with no schedule associated to it, for example, if
                /// there is no schedule at all.
                /// </summary>
                [pbr::OriginalName("UNSCHEDULED")] Unscheduled = 2,
                /// <summary>
                /// A trip that existed in the schedule but was removed.
                /// </summary>
                [pbr::OriginalName("CANCELED")] Canceled = 3,
            }

        }
        #endregion

    }

    /// <summary>
    /// Identification information for the vehicle performing the trip.
    /// </summary>
    public sealed partial class VehicleDescriptor : pb::IExtendableMessage<VehicleDescriptor>
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
#endif
    {
        private static readonly pb::MessageParser<VehicleDescriptor> _parser = new pb::MessageParser<VehicleDescriptor>(() => new VehicleDescriptor());
        private pb::UnknownFieldSet _unknownFields;
        private pb::ExtensionSet<VehicleDescriptor> _extensions;
        private pb::ExtensionSet<VehicleDescriptor> _Extensions { get { return _extensions; } }
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<VehicleDescriptor> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor
        {
            get { return global::STM.ExternalServiceProvider.Proto.GtfsRealtimeReflection.Descriptor.MessageTypes[9]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor
        {
            get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public VehicleDescriptor()
        {
            OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public VehicleDescriptor(VehicleDescriptor other) : this()
        {
            id_ = other.id_;
            label_ = other.label_;
            licensePlate_ = other.licensePlate_;
            _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            _extensions = pb::ExtensionSet.Clone(other._extensions);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public VehicleDescriptor Clone()
        {
            return new VehicleDescriptor(this);
        }

        /// <summary>Field number for the "id" field.</summary>
        public const int IdFieldNumber = 1;
        private readonly static string IdDefaultValue = "";

        private string id_;
        /// <summary>
        /// Internal system identification of the vehicle. Should be unique per
        /// vehicle, and can be used for tracking the vehicle as it proceeds through
        /// the system.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public string Id
        {
            get { return id_ ?? IdDefaultValue; }
            set
            {
                id_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
            }
        }
        /// <summary>Gets whether the "id" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasId
        {
            get { return id_ != null; }
        }
        /// <summary>Clears the value of the "id" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearId()
        {
            id_ = null;
        }

        /// <summary>Field number for the "label" field.</summary>
        public const int LabelFieldNumber = 2;
        private readonly static string LabelDefaultValue = "";

        private string label_;
        /// <summary>
        /// User visible label, i.e., something that must be shown to the passenger to
        /// help identify the correct vehicle.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public string Label
        {
            get { return label_ ?? LabelDefaultValue; }
            set
            {
                label_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
            }
        }
        /// <summary>Gets whether the "label" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasLabel
        {
            get { return label_ != null; }
        }
        /// <summary>Clears the value of the "label" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearLabel()
        {
            label_ = null;
        }

        /// <summary>Field number for the "license_plate" field.</summary>
        public const int LicensePlateFieldNumber = 3;
        private readonly static string LicensePlateDefaultValue = "";

        private string licensePlate_;
        /// <summary>
        /// The license plate of the vehicle.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public string LicensePlate
        {
            get { return licensePlate_ ?? LicensePlateDefaultValue; }
            set
            {
                licensePlate_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
            }
        }
        /// <summary>Gets whether the "license_plate" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasLicensePlate
        {
            get { return licensePlate_ != null; }
        }
        /// <summary>Clears the value of the "license_plate" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearLicensePlate()
        {
            licensePlate_ = null;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other)
        {
            return Equals(other as VehicleDescriptor);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(VehicleDescriptor other)
        {
            if (ReferenceEquals(other, null))
            {
                return false;
            }
            if (ReferenceEquals(other, this))
            {
                return true;
            }
            if (Id != other.Id) return false;
            if (Label != other.Label) return false;
            if (LicensePlate != other.LicensePlate) return false;
            if (!Equals(_extensions, other._extensions))
            {
                return false;
            }
            return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode()
        {
            int hash = 1;
            if (HasId) hash ^= Id.GetHashCode();
            if (HasLabel) hash ^= Label.GetHashCode();
            if (HasLicensePlate) hash ^= LicensePlate.GetHashCode();
            if (_extensions != null)
            {
                hash ^= _extensions.GetHashCode();
            }
            if (_unknownFields != null)
            {
                hash ^= _unknownFields.GetHashCode();
            }
            return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString()
        {
            return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output)
        {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            output.WriteRawMessage(this);
#else
      if (HasId) {
        output.WriteRawTag(10);
        output.WriteString(Id);
      }
      if (HasLabel) {
        output.WriteRawTag(18);
        output.WriteString(Label);
      }
      if (HasLicensePlate) {
        output.WriteRawTag(26);
        output.WriteString(LicensePlate);
      }
      if (_extensions != null) {
        _extensions.WriteTo(output);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
#endif
        }

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output)
        {
            if (HasId)
            {
                output.WriteRawTag(10);
                output.WriteString(Id);
            }
            if (HasLabel)
            {
                output.WriteRawTag(18);
                output.WriteString(Label);
            }
            if (HasLicensePlate)
            {
                output.WriteRawTag(26);
                output.WriteString(LicensePlate);
            }
            if (_extensions != null)
            {
                _extensions.WriteTo(ref output);
            }
            if (_unknownFields != null)
            {
                _unknownFields.WriteTo(ref output);
            }
        }
#endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize()
        {
            int size = 0;
            if (HasId)
            {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(Id);
            }
            if (HasLabel)
            {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(Label);
            }
            if (HasLicensePlate)
            {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(LicensePlate);
            }
            if (_extensions != null)
            {
                size += _extensions.CalculateSize();
            }
            if (_unknownFields != null)
            {
                size += _unknownFields.CalculateSize();
            }
            return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(VehicleDescriptor other)
        {
            if (other == null)
            {
                return;
            }
            if (other.HasId)
            {
                Id = other.Id;
            }
            if (other.HasLabel)
            {
                Label = other.Label;
            }
            if (other.HasLicensePlate)
            {
                LicensePlate = other.LicensePlate;
            }
            pb::ExtensionSet.MergeFrom(ref _extensions, other._extensions);
            _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input)
        {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            input.ReadRawMessage(this);
#else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            if (!pb::ExtensionSet.TryMergeFieldFrom(ref _extensions, input)) {
              _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            }
            break;
          case 10: {
            Id = input.ReadString();
            break;
          }
          case 18: {
            Label = input.ReadString();
            break;
          }
          case 26: {
            LicensePlate = input.ReadString();
            break;
          }
        }
      }
#endif
        }

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input)
        {
            uint tag;
            while ((tag = input.ReadTag()) != 0)
            {
                switch (tag)
                {
                    default:
                        if (!pb::ExtensionSet.TryMergeFieldFrom(ref _extensions, ref input))
                        {
                            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                        }
                        break;
                    case 10:
                        {
                            Id = input.ReadString();
                            break;
                        }
                    case 18:
                        {
                            Label = input.ReadString();
                            break;
                        }
                    case 26:
                        {
                            LicensePlate = input.ReadString();
                            break;
                        }
                }
            }
        }
#endif

        public TValue GetExtension<TValue>(pb::Extension<VehicleDescriptor, TValue> extension)
        {
            return pb::ExtensionSet.Get(ref _extensions, extension);
        }
        public pbc::RepeatedField<TValue> GetExtension<TValue>(pb::RepeatedExtension<VehicleDescriptor, TValue> extension)
        {
            return pb::ExtensionSet.Get(ref _extensions, extension);
        }
        public pbc::RepeatedField<TValue> GetOrInitializeExtension<TValue>(pb::RepeatedExtension<VehicleDescriptor, TValue> extension)
        {
            return pb::ExtensionSet.GetOrInitialize(ref _extensions, extension);
        }
        public void SetExtension<TValue>(pb::Extension<VehicleDescriptor, TValue> extension, TValue value)
        {
            pb::ExtensionSet.Set(ref _extensions, extension, value);
        }
        public bool HasExtension<TValue>(pb::Extension<VehicleDescriptor, TValue> extension)
        {
            return pb::ExtensionSet.Has(ref _extensions, extension);
        }
        public void ClearExtension<TValue>(pb::Extension<VehicleDescriptor, TValue> extension)
        {
            pb::ExtensionSet.Clear(ref _extensions, extension);
        }
        public void ClearExtension<TValue>(pb::RepeatedExtension<VehicleDescriptor, TValue> extension)
        {
            pb::ExtensionSet.Clear(ref _extensions, extension);
        }

    }

    /// <summary>
    /// A selector for an entity in a GTFS feed.
    /// </summary>
    public sealed partial class EntitySelector : pb::IExtendableMessage<EntitySelector>
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
#endif
    {
        private static readonly pb::MessageParser<EntitySelector> _parser = new pb::MessageParser<EntitySelector>(() => new EntitySelector());
        private pb::UnknownFieldSet _unknownFields;
        private pb::ExtensionSet<EntitySelector> _extensions;
        private pb::ExtensionSet<EntitySelector> _Extensions { get { return _extensions; } }
        private int _hasBits0;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<EntitySelector> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor
        {
            get { return global::STM.ExternalServiceProvider.Proto.GtfsRealtimeReflection.Descriptor.MessageTypes[10]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor
        {
            get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public EntitySelector()
        {
            OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public EntitySelector(EntitySelector other) : this()
        {
            _hasBits0 = other._hasBits0;
            agencyId_ = other.agencyId_;
            routeId_ = other.routeId_;
            routeType_ = other.routeType_;
            trip_ = other.trip_ != null ? other.trip_.Clone() : null;
            stopId_ = other.stopId_;
            _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            _extensions = pb::ExtensionSet.Clone(other._extensions);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public EntitySelector Clone()
        {
            return new EntitySelector(this);
        }

        /// <summary>Field number for the "agency_id" field.</summary>
        public const int AgencyIdFieldNumber = 1;
        private readonly static string AgencyIdDefaultValue = "";

        private string agencyId_;
        /// <summary>
        /// The values of the fields should correspond to the appropriate fields in the
        /// GTFS feed.
        /// At least one specifier must be given. If several are given, then the
        /// matching has to apply to all the given specifiers.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public string AgencyId
        {
            get { return agencyId_ ?? AgencyIdDefaultValue; }
            set
            {
                agencyId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
            }
        }
        /// <summary>Gets whether the "agency_id" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasAgencyId
        {
            get { return agencyId_ != null; }
        }
        /// <summary>Clears the value of the "agency_id" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearAgencyId()
        {
            agencyId_ = null;
        }

        /// <summary>Field number for the "route_id" field.</summary>
        public const int RouteIdFieldNumber = 2;
        private readonly static string RouteIdDefaultValue = "";

        private string routeId_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public string RouteId
        {
            get { return routeId_ ?? RouteIdDefaultValue; }
            set
            {
                routeId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
            }
        }
        /// <summary>Gets whether the "route_id" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasRouteId
        {
            get { return routeId_ != null; }
        }
        /// <summary>Clears the value of the "route_id" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearRouteId()
        {
            routeId_ = null;
        }

        /// <summary>Field number for the "route_type" field.</summary>
        public const int RouteTypeFieldNumber = 3;
        private readonly static int RouteTypeDefaultValue = 0;

        private int routeType_;
        /// <summary>
        /// corresponds to route_type in GTFS.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int RouteType
        {
            get { if ((_hasBits0 & 1) != 0) { return routeType_; } else { return RouteTypeDefaultValue; } }
            set
            {
                _hasBits0 |= 1;
                routeType_ = value;
            }
        }
        /// <summary>Gets whether the "route_type" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasRouteType
        {
            get { return (_hasBits0 & 1) != 0; }
        }
        /// <summary>Clears the value of the "route_type" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearRouteType()
        {
            _hasBits0 &= ~1;
        }

        /// <summary>Field number for the "trip" field.</summary>
        public const int TripFieldNumber = 4;
        private global::STM.ExternalServiceProvider.Proto.TripDescriptor trip_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::STM.ExternalServiceProvider.Proto.TripDescriptor Trip
        {
            get { return trip_; }
            set
            {
                trip_ = value;
            }
        }

        /// <summary>Field number for the "stop_id" field.</summary>
        public const int StopIdFieldNumber = 5;
        private readonly static string StopIdDefaultValue = "";

        private string stopId_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public string StopId
        {
            get { return stopId_ ?? StopIdDefaultValue; }
            set
            {
                stopId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
            }
        }
        /// <summary>Gets whether the "stop_id" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasStopId
        {
            get { return stopId_ != null; }
        }
        /// <summary>Clears the value of the "stop_id" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearStopId()
        {
            stopId_ = null;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other)
        {
            return Equals(other as EntitySelector);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(EntitySelector other)
        {
            if (ReferenceEquals(other, null))
            {
                return false;
            }
            if (ReferenceEquals(other, this))
            {
                return true;
            }
            if (AgencyId != other.AgencyId) return false;
            if (RouteId != other.RouteId) return false;
            if (RouteType != other.RouteType) return false;
            if (!object.Equals(Trip, other.Trip)) return false;
            if (StopId != other.StopId) return false;
            if (!Equals(_extensions, other._extensions))
            {
                return false;
            }
            return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode()
        {
            int hash = 1;
            if (HasAgencyId) hash ^= AgencyId.GetHashCode();
            if (HasRouteId) hash ^= RouteId.GetHashCode();
            if (HasRouteType) hash ^= RouteType.GetHashCode();
            if (trip_ != null) hash ^= Trip.GetHashCode();
            if (HasStopId) hash ^= StopId.GetHashCode();
            if (_extensions != null)
            {
                hash ^= _extensions.GetHashCode();
            }
            if (_unknownFields != null)
            {
                hash ^= _unknownFields.GetHashCode();
            }
            return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString()
        {
            return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output)
        {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            output.WriteRawMessage(this);
#else
      if (HasAgencyId) {
        output.WriteRawTag(10);
        output.WriteString(AgencyId);
      }
      if (HasRouteId) {
        output.WriteRawTag(18);
        output.WriteString(RouteId);
      }
      if (HasRouteType) {
        output.WriteRawTag(24);
        output.WriteInt32(RouteType);
      }
      if (trip_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(Ride);
      }
      if (HasStopId) {
        output.WriteRawTag(42);
        output.WriteString(StopId);
      }
      if (_extensions != null) {
        _extensions.WriteTo(output);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
#endif
        }

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output)
        {
            if (HasAgencyId)
            {
                output.WriteRawTag(10);
                output.WriteString(AgencyId);
            }
            if (HasRouteId)
            {
                output.WriteRawTag(18);
                output.WriteString(RouteId);
            }
            if (HasRouteType)
            {
                output.WriteRawTag(24);
                output.WriteInt32(RouteType);
            }
            if (trip_ != null)
            {
                output.WriteRawTag(34);
                output.WriteMessage(Trip);
            }
            if (HasStopId)
            {
                output.WriteRawTag(42);
                output.WriteString(StopId);
            }
            if (_extensions != null)
            {
                _extensions.WriteTo(ref output);
            }
            if (_unknownFields != null)
            {
                _unknownFields.WriteTo(ref output);
            }
        }
#endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize()
        {
            int size = 0;
            if (HasAgencyId)
            {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(AgencyId);
            }
            if (HasRouteId)
            {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(RouteId);
            }
            if (HasRouteType)
            {
                size += 1 + pb::CodedOutputStream.ComputeInt32Size(RouteType);
            }
            if (trip_ != null)
            {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(Trip);
            }
            if (HasStopId)
            {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(StopId);
            }
            if (_extensions != null)
            {
                size += _extensions.CalculateSize();
            }
            if (_unknownFields != null)
            {
                size += _unknownFields.CalculateSize();
            }
            return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(EntitySelector other)
        {
            if (other == null)
            {
                return;
            }
            if (other.HasAgencyId)
            {
                AgencyId = other.AgencyId;
            }
            if (other.HasRouteId)
            {
                RouteId = other.RouteId;
            }
            if (other.HasRouteType)
            {
                RouteType = other.RouteType;
            }
            if (other.trip_ != null)
            {
                if (trip_ == null)
                {
                    Trip = new global::STM.ExternalServiceProvider.Proto.TripDescriptor();
                }
                Trip.MergeFrom(other.Trip);
            }
            if (other.HasStopId)
            {
                StopId = other.StopId;
            }
            pb::ExtensionSet.MergeFrom(ref _extensions, other._extensions);
            _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input)
        {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            input.ReadRawMessage(this);
#else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            if (!pb::ExtensionSet.TryMergeFieldFrom(ref _extensions, input)) {
              _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            }
            break;
          case 10: {
            AgencyId = input.ReadString();
            break;
          }
          case 18: {
            RouteId = input.ReadString();
            break;
          }
          case 24: {
            RouteType = input.ReadInt32();
            break;
          }
          case 34: {
            if (trip_ == null) {
              Ride = new global::TransitRealtime.TripDescriptor();
            }
            input.ReadMessage(Ride);
            break;
          }
          case 42: {
            StopId = input.ReadString();
            break;
          }
        }
      }
#endif
        }

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input)
        {
            uint tag;
            while ((tag = input.ReadTag()) != 0)
            {
                switch (tag)
                {
                    default:
                        if (!pb::ExtensionSet.TryMergeFieldFrom(ref _extensions, ref input))
                        {
                            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                        }
                        break;
                    case 10:
                        {
                            AgencyId = input.ReadString();
                            break;
                        }
                    case 18:
                        {
                            RouteId = input.ReadString();
                            break;
                        }
                    case 24:
                        {
                            RouteType = input.ReadInt32();
                            break;
                        }
                    case 34:
                        {
                            if (trip_ == null)
                            {
                                Trip = new global::STM.ExternalServiceProvider.Proto.TripDescriptor();
                            }
                            input.ReadMessage(Trip);
                            break;
                        }
                    case 42:
                        {
                            StopId = input.ReadString();
                            break;
                        }
                }
            }
        }
#endif

        public TValue GetExtension<TValue>(pb::Extension<EntitySelector, TValue> extension)
        {
            return pb::ExtensionSet.Get(ref _extensions, extension);
        }
        public pbc::RepeatedField<TValue> GetExtension<TValue>(pb::RepeatedExtension<EntitySelector, TValue> extension)
        {
            return pb::ExtensionSet.Get(ref _extensions, extension);
        }
        public pbc::RepeatedField<TValue> GetOrInitializeExtension<TValue>(pb::RepeatedExtension<EntitySelector, TValue> extension)
        {
            return pb::ExtensionSet.GetOrInitialize(ref _extensions, extension);
        }
        public void SetExtension<TValue>(pb::Extension<EntitySelector, TValue> extension, TValue value)
        {
            pb::ExtensionSet.Set(ref _extensions, extension, value);
        }
        public bool HasExtension<TValue>(pb::Extension<EntitySelector, TValue> extension)
        {
            return pb::ExtensionSet.Has(ref _extensions, extension);
        }
        public void ClearExtension<TValue>(pb::Extension<EntitySelector, TValue> extension)
        {
            pb::ExtensionSet.Clear(ref _extensions, extension);
        }
        public void ClearExtension<TValue>(pb::RepeatedExtension<EntitySelector, TValue> extension)
        {
            pb::ExtensionSet.Clear(ref _extensions, extension);
        }

    }

    /// <summary>
    /// An internationalized message containing per-language versions of a snippet of
    /// text or a URL.
    /// One of the strings from a message will be picked up. The resolution proceeds
    /// as follows:
    /// 1. If the UI language matches the language code of a translation,
    ///    the first matching translation is picked.
    /// 2. If a default UI language (e.g., English) matches the language code of a
    ///    translation, the first matching translation is picked.
    /// 3. If some translation has an unspecified language code, that translation is
    ///    picked.
    /// </summary>
    public sealed partial class TranslatedString : pb::IExtendableMessage<TranslatedString>
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
#endif
    {
        private static readonly pb::MessageParser<TranslatedString> _parser = new pb::MessageParser<TranslatedString>(() => new TranslatedString());
        private pb::UnknownFieldSet _unknownFields;
        private pb::ExtensionSet<TranslatedString> _extensions;
        private pb::ExtensionSet<TranslatedString> _Extensions { get { return _extensions; } }
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<TranslatedString> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor
        {
            get { return global::STM.ExternalServiceProvider.Proto.GtfsRealtimeReflection.Descriptor.MessageTypes[11]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor
        {
            get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public TranslatedString()
        {
            OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public TranslatedString(TranslatedString other) : this()
        {
            translation_ = other.translation_.Clone();
            _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            _extensions = pb::ExtensionSet.Clone(other._extensions);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public TranslatedString Clone()
        {
            return new TranslatedString(this);
        }

        /// <summary>Field number for the "translation" field.</summary>
        public const int TranslationFieldNumber = 1;
        private static readonly pb::FieldCodec<global::STM.ExternalServiceProvider.Proto.TranslatedString.Types.Translation> _repeated_translation_codec
            = pb::FieldCodec.ForMessage(10, global::STM.ExternalServiceProvider.Proto.TranslatedString.Types.Translation.Parser);
        private readonly pbc::RepeatedField<global::STM.ExternalServiceProvider.Proto.TranslatedString.Types.Translation> translation_ = new pbc::RepeatedField<global::STM.ExternalServiceProvider.Proto.TranslatedString.Types.Translation>();
        /// <summary>
        /// At least one translation must be provided.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public pbc::RepeatedField<global::STM.ExternalServiceProvider.Proto.TranslatedString.Types.Translation> Translation
        {
            get { return translation_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other)
        {
            return Equals(other as TranslatedString);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(TranslatedString other)
        {
            if (ReferenceEquals(other, null))
            {
                return false;
            }
            if (ReferenceEquals(other, this))
            {
                return true;
            }
            if (!translation_.Equals(other.translation_)) return false;
            if (!Equals(_extensions, other._extensions))
            {
                return false;
            }
            return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode()
        {
            int hash = 1;
            hash ^= translation_.GetHashCode();
            if (_extensions != null)
            {
                hash ^= _extensions.GetHashCode();
            }
            if (_unknownFields != null)
            {
                hash ^= _unknownFields.GetHashCode();
            }
            return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString()
        {
            return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output)
        {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            output.WriteRawMessage(this);
#else
      translation_.WriteTo(output, _repeated_translation_codec);
      if (_extensions != null) {
        _extensions.WriteTo(output);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
#endif
        }

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output)
        {
            translation_.WriteTo(ref output, _repeated_translation_codec);
            if (_extensions != null)
            {
                _extensions.WriteTo(ref output);
            }
            if (_unknownFields != null)
            {
                _unknownFields.WriteTo(ref output);
            }
        }
#endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize()
        {
            int size = 0;
            size += translation_.CalculateSize(_repeated_translation_codec);
            if (_extensions != null)
            {
                size += _extensions.CalculateSize();
            }
            if (_unknownFields != null)
            {
                size += _unknownFields.CalculateSize();
            }
            return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(TranslatedString other)
        {
            if (other == null)
            {
                return;
            }
            translation_.Add(other.translation_);
            pb::ExtensionSet.MergeFrom(ref _extensions, other._extensions);
            _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input)
        {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            input.ReadRawMessage(this);
#else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            if (!pb::ExtensionSet.TryMergeFieldFrom(ref _extensions, input)) {
              _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            }
            break;
          case 10: {
            translation_.AddEntriesFrom(input, _repeated_translation_codec);
            break;
          }
        }
      }
#endif
        }

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input)
        {
            uint tag;
            while ((tag = input.ReadTag()) != 0)
            {
                switch (tag)
                {
                    default:
                        if (!pb::ExtensionSet.TryMergeFieldFrom(ref _extensions, ref input))
                        {
                            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                        }
                        break;
                    case 10:
                        {
                            translation_.AddEntriesFrom(ref input, _repeated_translation_codec);
                            break;
                        }
                }
            }
        }
#endif

        public TValue GetExtension<TValue>(pb::Extension<TranslatedString, TValue> extension)
        {
            return pb::ExtensionSet.Get(ref _extensions, extension);
        }
        public pbc::RepeatedField<TValue> GetExtension<TValue>(pb::RepeatedExtension<TranslatedString, TValue> extension)
        {
            return pb::ExtensionSet.Get(ref _extensions, extension);
        }
        public pbc::RepeatedField<TValue> GetOrInitializeExtension<TValue>(pb::RepeatedExtension<TranslatedString, TValue> extension)
        {
            return pb::ExtensionSet.GetOrInitialize(ref _extensions, extension);
        }
        public void SetExtension<TValue>(pb::Extension<TranslatedString, TValue> extension, TValue value)
        {
            pb::ExtensionSet.Set(ref _extensions, extension, value);
        }
        public bool HasExtension<TValue>(pb::Extension<TranslatedString, TValue> extension)
        {
            return pb::ExtensionSet.Has(ref _extensions, extension);
        }
        public void ClearExtension<TValue>(pb::Extension<TranslatedString, TValue> extension)
        {
            pb::ExtensionSet.Clear(ref _extensions, extension);
        }
        public void ClearExtension<TValue>(pb::RepeatedExtension<TranslatedString, TValue> extension)
        {
            pb::ExtensionSet.Clear(ref _extensions, extension);
        }

        #region Nested types
        /// <summary>Container for nested types declared in the TranslatedString message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static partial class Types
        {
            public sealed partial class Translation : pb::IExtendableMessage<Translation>
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
#endif
            {
                private static readonly pb::MessageParser<Translation> _parser = new pb::MessageParser<Translation>(() => new Translation());
                private pb::UnknownFieldSet _unknownFields;
                private pb::ExtensionSet<Translation> _extensions;
                private pb::ExtensionSet<Translation> _Extensions { get { return _extensions; } }
                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public static pb::MessageParser<Translation> Parser { get { return _parser; } }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public static pbr::MessageDescriptor Descriptor
                {
                    get { return global::STM.ExternalServiceProvider.Proto.TranslatedString.Descriptor.NestedTypes[0]; }
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                pbr::MessageDescriptor pb::IMessage.Descriptor
                {
                    get { return Descriptor; }
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public Translation()
                {
                    OnConstruction();
                }

                partial void OnConstruction();

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public Translation(Translation other) : this()
                {
                    text_ = other.text_;
                    language_ = other.language_;
                    _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
                    _extensions = pb::ExtensionSet.Clone(other._extensions);
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public Translation Clone()
                {
                    return new Translation(this);
                }

                /// <summary>Field number for the "text" field.</summary>
                public const int TextFieldNumber = 1;
                private readonly static string TextDefaultValue = "";

                private string text_;
                /// <summary>
                /// A UTF-8 string containing the message.
                /// </summary>
                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public string Text
                {
                    get { return text_ ?? TextDefaultValue; }
                    set
                    {
                        text_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
                    }
                }
                /// <summary>Gets whether the "text" field is set</summary>
                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public bool HasText
                {
                    get { return text_ != null; }
                }
                /// <summary>Clears the value of the "text" field</summary>
                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public void ClearText()
                {
                    text_ = null;
                }

                /// <summary>Field number for the "language" field.</summary>
                public const int LanguageFieldNumber = 2;
                private readonly static string LanguageDefaultValue = "";

                private string language_;
                /// <summary>
                /// BCP-47 language code. Can be omitted if the language is unknown or if
                /// no i18n is done at all for the feed. At most one translation is
                /// allowed to have an unspecified language tag.
                /// </summary>
                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public string Language
                {
                    get { return language_ ?? LanguageDefaultValue; }
                    set
                    {
                        language_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
                    }
                }
                /// <summary>Gets whether the "language" field is set</summary>
                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public bool HasLanguage
                {
                    get { return language_ != null; }
                }
                /// <summary>Clears the value of the "language" field</summary>
                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public void ClearLanguage()
                {
                    language_ = null;
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public override bool Equals(object other)
                {
                    return Equals(other as Translation);
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public bool Equals(Translation other)
                {
                    if (ReferenceEquals(other, null))
                    {
                        return false;
                    }
                    if (ReferenceEquals(other, this))
                    {
                        return true;
                    }
                    if (Text != other.Text) return false;
                    if (Language != other.Language) return false;
                    if (!Equals(_extensions, other._extensions))
                    {
                        return false;
                    }
                    return Equals(_unknownFields, other._unknownFields);
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public override int GetHashCode()
                {
                    int hash = 1;
                    if (HasText) hash ^= Text.GetHashCode();
                    if (HasLanguage) hash ^= Language.GetHashCode();
                    if (_extensions != null)
                    {
                        hash ^= _extensions.GetHashCode();
                    }
                    if (_unknownFields != null)
                    {
                        hash ^= _unknownFields.GetHashCode();
                    }
                    return hash;
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public override string ToString()
                {
                    return pb::JsonFormatter.ToDiagnosticString(this);
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public void WriteTo(pb::CodedOutputStream output)
                {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
                    output.WriteRawMessage(this);
#else
          if (HasText) {
            output.WriteRawTag(10);
            output.WriteString(Text);
          }
          if (HasLanguage) {
            output.WriteRawTag(18);
            output.WriteString(Language);
          }
          if (_extensions != null) {
            _extensions.WriteTo(output);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
#endif
                }

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output)
                {
                    if (HasText)
                    {
                        output.WriteRawTag(10);
                        output.WriteString(Text);
                    }
                    if (HasLanguage)
                    {
                        output.WriteRawTag(18);
                        output.WriteString(Language);
                    }
                    if (_extensions != null)
                    {
                        _extensions.WriteTo(ref output);
                    }
                    if (_unknownFields != null)
                    {
                        _unknownFields.WriteTo(ref output);
                    }
                }
#endif

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public int CalculateSize()
                {
                    int size = 0;
                    if (HasText)
                    {
                        size += 1 + pb::CodedOutputStream.ComputeStringSize(Text);
                    }
                    if (HasLanguage)
                    {
                        size += 1 + pb::CodedOutputStream.ComputeStringSize(Language);
                    }
                    if (_extensions != null)
                    {
                        size += _extensions.CalculateSize();
                    }
                    if (_unknownFields != null)
                    {
                        size += _unknownFields.CalculateSize();
                    }
                    return size;
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public void MergeFrom(Translation other)
                {
                    if (other == null)
                    {
                        return;
                    }
                    if (other.HasText)
                    {
                        Text = other.Text;
                    }
                    if (other.HasLanguage)
                    {
                        Language = other.Language;
                    }
                    pb::ExtensionSet.MergeFrom(ref _extensions, other._extensions);
                    _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public void MergeFrom(pb::CodedInputStream input)
                {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
                    input.ReadRawMessage(this);
#else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                if (!pb::ExtensionSet.TryMergeFieldFrom(ref _extensions, input)) {
                  _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                }
                break;
              case 10: {
                Text = input.ReadString();
                break;
              }
              case 18: {
                Language = input.ReadString();
                break;
              }
            }
          }
#endif
                }

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input)
                {
                    uint tag;
                    while ((tag = input.ReadTag()) != 0)
                    {
                        switch (tag)
                        {
                            default:
                                if (!pb::ExtensionSet.TryMergeFieldFrom(ref _extensions, ref input))
                                {
                                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                                }
                                break;
                            case 10:
                                {
                                    Text = input.ReadString();
                                    break;
                                }
                            case 18:
                                {
                                    Language = input.ReadString();
                                    break;
                                }
                        }
                    }
                }
#endif

                public TValue GetExtension<TValue>(pb::Extension<Translation, TValue> extension)
                {
                    return pb::ExtensionSet.Get(ref _extensions, extension);
                }
                public pbc::RepeatedField<TValue> GetExtension<TValue>(pb::RepeatedExtension<Translation, TValue> extension)
                {
                    return pb::ExtensionSet.Get(ref _extensions, extension);
                }
                public pbc::RepeatedField<TValue> GetOrInitializeExtension<TValue>(pb::RepeatedExtension<Translation, TValue> extension)
                {
                    return pb::ExtensionSet.GetOrInitialize(ref _extensions, extension);
                }
                public void SetExtension<TValue>(pb::Extension<Translation, TValue> extension, TValue value)
                {
                    pb::ExtensionSet.Set(ref _extensions, extension, value);
                }
                public bool HasExtension<TValue>(pb::Extension<Translation, TValue> extension)
                {
                    return pb::ExtensionSet.Has(ref _extensions, extension);
                }
                public void ClearExtension<TValue>(pb::Extension<Translation, TValue> extension)
                {
                    pb::ExtensionSet.Clear(ref _extensions, extension);
                }
                public void ClearExtension<TValue>(pb::RepeatedExtension<Translation, TValue> extension)
                {
                    pb::ExtensionSet.Clear(ref _extensions, extension);
                }

            }

        }
        #endregion

    }

    #endregion

}

#endregion Designer generated code
